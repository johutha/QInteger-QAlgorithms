\chapter{Einführung}
\section{Vorwort}
Das Gebiet der Quantencomputer ist zweifellos eines der vielversprechendsten Forschungsgebiete. Quantencomputer würden uns theoretisch erlauben, Berechnungen auszuführen, die auf klassischen Computern nicht effizient ausgeführt werden können. Diese mathematischen Konstrukte werden in der Zukunft wahrscheinlich eine grössere Rolle spielen. 

Immer wieder liest man in Zeitungs- und Journalartikeln über Relisierungen von Quantencomputern und immer wieder wurde von Durchbrüchen gesprochen. So wie zum Beispiel, als Google 2019 einen Artikel im Journal \grqq Nature\grqq{} publizierte, in welchem sie behaupteten, die \grqq Quantenüberlegenheit\grqq{} erreicht zu haben (\cite{GSP}), was gleich darauf von der IBM in ihrem Blog angezweifelt wurde (\cite{IBM}).

Aus diesem Grund ist es meiner Meinung nach ein guter Zeitpunkt, um sich vertieft mit dem Thema auseinanderzusetzen. Ich habe mich deshalb entschieden, mich auf diese Reise zu begeben und im Rahmen meiner Maturitätsarbeit zu versuchen zu verstehen, wie Quantencomputer funktionieren, um danach in einem nächsten Schritt arithmetische Operationen sowie den Shor-Algorithmus zu implementieren. Die grösste Schwierigkeit, mit der ich mich auf meinem Weg konfrontiert sah, war es, die Quantenalgorithmen zu debuggen.

% TODO Sprache überarbeiten
Doch es dauerte immer eine Weile, bis etwas funktionierte. In der Tat denke ich, dass die grösste Schwierigkeit, die ich hatte, war, die Quantenalgorithmen zu debuggen. Mein Code war am Anfang noch sehr fehlerhaft und diese Fehler zu finden war schwierig. Dies liegt auch daran, dass Qubits schwierigere Konstrukte sind, so dass deren momentanen mit deren geplanten Zuständen zu vergleichen und zu finden, wieso etwas nicht stimmt, Stunden in Anspruch nehmen konnte.

In der Tat ist es meiner Meinung nach nicht sehr einfach, in dieses Gebiet einzusteigen. Auch deshalb soll meine Arbeit dazu dienen, zusammen mit der angegebenen Fachliteratur, den Einstieg zu vereinfachen. Dafür werden aber Kentnisse der linearen Algebra vorausgesetzt, da diese sehr wichtig ist, um die mathematische Struktur zu verstehen. Zum Einstieg in die lineare Algebra habe ich selbst das Buch \grqq Lineare Algebra\grqq{} von Gerd Fischer (siehe \cite{LA}) gelesen und empfehle dieses Buch, um sich die Grundlagen der linearen Algebra zu erarbeiten.

Ich habe mich sowohl damit auseinandergesetzt, wie arithmetische Operationen auf Quantencomputern programmiert werden können, als auch, wie man damit Zahlen faktorisieren kann. Was ich gelernt habe, habe ich in Code umgesetzt. Ich habe zwei Programmbibliotheken implementiert, die ich in Abschnitt 1.2 genauer beschreibe und in welchen man alle in dieser Arbeit betrachteten Operationen als Code finden kann.  Zudem habe ich bei der Implementierung gezielt darauf geachtet, dass diese Bibliotheken auch in späteren Projekten gut verwendet werden können und ich habe vor, diese Bibliotheken in Zukunft kontinuierlich zu erweitern und Implementierungen anderer Quantenalgorithmen hinzuzufügen, so dass sie aktuell bleiben. 

\section{Die QInteger- und die QAlgorithm-Libraries und eine Implementierung des Faktorisierungsalgorithmus}
Das Produkt dieser Maturitätsarbeit sind zwei Programmbibliotheken, welche Algorithmen für Quantencomputer bereitstellen. Diese Programmbibliotheken sind in der Programmiersprache Q\# geschrieben, einer Quantenprogrammiersprache entwickelt von Microsoft. Das Quantum Development Kit (QDK) von Microsoft beinhaltet dabei nicht nur die Sprache Q\#, sondern auch einen Simulator, auf welchem man den Code ausführen kann. Gleichzeitig ist es das Ziel der Sprache, dass man sie auf echten Quantencomputern einsetzen kann, sobald diese genug weit entwickelt sein werden.
\paragraph{}
Die beiden Bibliotheken sollen mathematische Operationen auf Quantencomputern vereinfachen. Hier ein kurzer Überblick über ihre Funktionen: %TODO Besseres Wort als Funktionen
\begin{itemize}
  \item Die \textit{QInteger-Library} definiert mit dem Typ \grqq QInt\grqq{} die grundlegende Datenstruktur \grqq Zahl\grqq{} auf einem Quantencomputer. Zudem stellt sie arithmetische Operationen und nützliche Funktionen für den Typ \grqq QInt\grqq{} bereit. %TODO besseres Wort für zudem
  \item In der \textit{QAlgorithms-Library} sind Algorithmen für Quantencomputer implementiert, darunter auch der quantenbasierte Teil von Shors Algorithmus zur Faktorisierung von Zahlen, welcher zweifelsohne einer der nennenswertesten Errungenschaften auf dem Gebiets der Quantencomputer ist.
\end{itemize}
Diese beiden Bibliotheken stellen generelle, nützliche Funktionen für Quantencomputer bereit, welche auch zur Vereinfachung in anderen Projekten gebraucht werden können. Den Code zu diesen Programmbibliotheken kann man auf GitHub finden, wo er in Zukunft einige Aktualisierungen erhalten wird. Auf GitHub ist er unter folgendem Link verfügbar:
\paragraph{}
\centerline{ https://github.com/johutha/QInteger-QAlgorithms }
\paragraph{}

Ich habe Q\# gewählt, da es aktuell eine der populärsten Quantenprogrammiersprachen ist, über eine gute Dokumentation verfügt, gut unterstützt und regelmässig aktualisiert wird. Zudem kann der Compiler automatisch zu einer Quantenoperation deren Inverses oder deren kontrollierte Version generieren \footnote{Siehe auch Kapitel 2.2}, was den Code kürzer und übersichtlicher macht.

\paragraph{}

Nebst diesen beiden Bibliotheken finden sich im GitHub-Repository weitere Projekte. In einem dieser Projekte ist der \grqq Factorizer\grqq{} implementiert, welcher zusammen mit den Quanten-Programmbibliotheken eine komplette Implementierung von Shors Algorithmus bilden. Dazu sind im Projekt auch andere Faktorisierungsalgorithmen programmiert, so dass man diese miteinander vergleichen kann.

Im Weiteren befindet sich im Repository ein Projekt für eine einfache Konsolen-Applikation, welche den \grqq Factorizer\grqq{} benüützt, so dass man diesen als Proof of Concept ausprobieren kann. Zudem gibt es ein Projekt für einen Zeitmesser, welcher misst, wie lange der \grqq Factorizer \grqq{} benötigt.

Zudem befinden sich im Repository drei weitere Projekte, in welchen Unit-Tests implementiert sind. Unit-Tests testen die verschiedenen Komponenten einzeln, wodurch man einfacher Implementierungsfehler lokalisieren und Bugs finden kann.