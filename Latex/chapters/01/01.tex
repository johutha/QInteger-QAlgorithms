\chapter{Einführung}
\section{Vorwort}
Das Gebiet der Quantencomputer ist zweifelsohne eines der vielsprechendsten Forschungsgebiete. Quantencomputer erlauben uns, Berechnungen auszuführen, die auf klassischen Computern nicht effizient ausgeführt werden können. Diese mathematischen Konstrukte werden in der Zukunft wahrscheinlich eine grössere Rolle spielen. Deshalb ist es meiner Meinung nach kein schlechter Zeitpunkt, um sich mit dem Thema zu beschäftigen. Deshalb soll diese Arbeit auch dazu dienen, dem Leser den Einstieg in dieses komplexe Themengebiet zu vereinfachen. 

Ich persönlich habe immer wieder Zeitungs- und Journalartikel über Relisierungen von Quantencomputern gelesen und immer wieder wurde von Durchbrüchen gesprochen. So wie zum Beispiel, als Google 2019 einen Artikel im Journal \grqq Nature\grqq{} publizierte, in welchem sie behaupteten, die \grqq Quantenüberlegenheit\grqq{} erreicht zu haben (siehe \cite{GSP}), was gleich darauf von der IBM in ihrem Blog angezweifelt wurde (siehe \cite{IBM}). Das Gebiet der Quantencomputer erweckte so mein Interesse, jedoch verstand ich nichts. Bis ich mich entschieden habe, auf diese \grqq Reise\grqq{} aufzubrechen und im Rahmen dieser Maturitätsarbeit probiert, zu verstehen, wie Quantencomputer funktionieren. Ich habe dabei sehr viel gelernt, doch lange gebraucht, bis ich die Grundlagen nur Ansatzweise verstanden habe. In der Tat ist es meiner Meinung nach nicht sehr einfach, in dieses Gebiet einzusteigen. Auch deshalb soll meine Arbeit dazu dienen, zusammen mit der angegebenen Fachliteratur, den Einstieg zu vereinfachen. Dafür werden aber Kentnisse der linearen Algebra vorausgesetzt, da diese sehr wichtig ist, um die mathematische Struktur zu verstehen. Zum Einstieg in die lineare Algebra habe ich selbst das Buch "Lineare Algebra" von Gerd Fischer (siehe \cite{LA}) gelesen und empfehle dieses Buch, um sich die Grundlagen der linearen Algebra zu erarbeiten.

Ich habe mich damit auseinandergesetzt, wie einerseits arithmetische Operationen auf Quantencomputern programmiert werden können, anderseits auch damit, wie man damit Zahlen faktorisieren kann. Das, was ich gelernt habe, habe ich auch in Code umgesetzt. Ich habe zwei Programmbibliotheken implementiert, die ich im Abschnitt 1.2 genauer beschreiben werde, in welchen man alle in dieser Arbeit betrachteten Operationen als Code finden kann. Zudem habe ich bei der Implementation darauf geachtet, dass diese Bibliotheken auch in anderen Projekten gut verwendet werden können, und ich habe vor, diese Bibliotheken in Zukunft zu erweitern und Implementationen anderer Quantenalgorithmen zuzufügen, so dass sie aktuell bleibt.

\section{Mein Produkt: Die QInteger- und die QAlgorithm-Libraries und eine Implementation des Faktorisierungsalgorithmus}
Das Produkt dieser Maturitätsarbeit sind zwei Programmbibliotheken, welche Algorithmen für Quantencomputer bereitstellen. Diese Programmbibliotheken sind in der Programmiersprache Q\# geschrieben, einer Quantenprogrammiersprache entwickelt von Microsoft. Das Quantum Development Kit (QDK) von Microsoft beinhaltet dabei nicht nur die Sprache Q\#, sondern auch einen Simulator, auf welchem man den Code ausführen kann. Gleichzeitig ist es das Ziel der Sprache, dass man sie auf echten Quantencomputern einsetzen kann, sobald diese genug weit entwickelt sein werden.

Die beiden Bibliotheken sollen mathematische Operationen auf Quantencomputern vereinfachen. Hier ein kurzer Überblick über ihre Funktionen: %TODO Besseres Wort als Funktionen
\begin{itemize}
  \item Die \textit{QInteger-Library} definiert mit dem Typ \grqq QInt\grqq{} die grundlegende Datenstruktur \grqq Zahl\grqq{} auf einem Quantencomputer. Zudem stellt sie arithmetische Operationen und nützliche Funktionen für den Typ \grqq QInt\grqq{} bereit. %TODO besseres Wort für zudem
  \item In der \textit{QAlgorithms-Library} sind Algorithmen für Quantencomputer implementiert, darunter auch der quantenbasierten Teil von Shors Algorithmus, welcher zweifelsohne einer der nennenswertesten Errungenschaften auf dem Gebiets der Quantencomputer ist.
\end{itemize}
Diese beiden Bibliotheken stellen generelle, nützliche Funktionen für Quantencomputer bereit, welche auch zur Vereinfachung in anderen Projekten grebraucht werden kann. Den Code zu diesen Programmbibliotheken habe ich im Appendix angefügt und man kann ihn auch auf GitHub finden, wo er in Zukunft einige Aktualisierungen erhalten wird. Auf GitHub ist er unter folgendem Link verfügbar: https://github.com/johutha/QInteger-QAlgorithms

Ich habe Q\# gewählt, da es aktuell eine der populärsten Quantenprogrammiersprachen ist, über eine gute Dokumentation verfügt, gut unterstützt und regelmässig aktualisiert wird. Zudem kann der Compiler automatisch zu einer Quantenoperation deren Inverses oder deren kontrollierte Version generieren \footnote{Siehe auch TODO Seitenzahl}, was den Code kürzer und übersichtlicher macht.

Nebst diesen beiden Bibliotheken finden sich im GitHub-Repository weitere Projekte. In einem dieser Projekte ist der \grqq Factorizer\grqq{} implementiert. Dieser ist modular entworfen: Dem Factorizer gibt man ein Modul zum Primzahlentest und ein Modul zum Berechnen der Ordnung einer Zahl mit. %TODO besseres Wort für mitgeben
Diese Modularität erlaubt es, verschiedene Algorithmen miteinander zu vergleichen. Neben dem \grqq Factorizer\grqq{} sind in diesem Projekt mehrere Module implementiert. Eines dieser Module benutzt dabei den quantenbasierten Teil von Shors Algorithmus und startet den Simulator, sodass es zusammen mit dem \grqq Factorizer\grqq{} eine komplette Implementation von Shors Algorithmus bildet.

Im Weiteren befindet sich im Repository ein Projekt für eine einfache Konsolen-Applikation, welche diese beiden \grqq Factorizer\grqq{} mit verschiedenen Modulen anwendet, als Proof of Concept. Zudem gibt es ein Projekt für einen Zeitmesser, welcher misst, wie lange \grqq Factorizer \grqq{} benötigt.

Zudem befinden sich im Repository drei weitere Projekte, in welchen Unit-Tests implementiert sind. Unit-Tests testen die verschiedenen Komponenten einzeln, wodurch man einfacher Implementationsfehler lokalisieren und Bugs finden kann.