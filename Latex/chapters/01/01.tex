\chapter{Einführung}
\section{Vorwort}
\section{Mein Produkt - Die QInteger- und die QAlgorithm-Libraries und ein Faktorisierungs-Algorithmus}
Das Produkt dieser Maturaarbeit sind zwei Programmbibliotheken, welche Algorithmen für Quantencomputer bereitstellen. Diese Programmbilbiotheken sind in der Programmiersprache Q\# geschrieben, einer Quantenprogrammiersprache entwickelt von Microsoft. Das Quantum Development Kit (QDK) von Microsoft beinhaltet dabei nicht nur die Sprache Q\#, sondern auch einen Simulator, auf welchem man den Code ausführen kann. Gleichzeitig ist das Ziel der Sprache, dass man sie auf echten Quantencomputern einsetzen kann, sobald diese genug weit entwickelt sind.

Die beiden Bibliotheken sollen mathematische Operationen auf Quantencomputern vereinfachen. Hier ein kurzer Überblick über die Funktionen der Bilbiotheken:
\begin{itemize}
    \item Die \textit{QInteger-Library} definiert mit dem Typ "QInt" die grundlegende Datenstruktur "Zahl" auf einem Quantencomputer. Dazu stellt sie arithmetische Operationen und nützliche Funktionen für den Typ "QInt" bereit.
    \item In der \textit{QAlgorithms-Library} sind Algorithmen für Quantencomputer implementiert, darunter auch den quantenbasierten Teil von Shors Algorithmus, welcher zweifelsohne einer der nennenswertesten Erfolge des Gebiets der Quantencomputer ist.
\end{itemize}
Diese beiden Bibliotheken stellen generelle, nützliche Funktionen für Quantencomputer bereit, die man in anderen Projekten gebrauchen kann. Den Code zu diesen Libraries habe ich im Appendix angefügt und man kann ihn auch auf GitHub finden, wo er auch einige Aktualisierungen erhalten wird. Auf GitHub ist er unter folgendem Link verfügbar: https://github.com/johutha/QInteger-QAlgorithms

Ich habe Q\# gewählt, da es momentan eine der populärsten Quantenprogrammiersprachen ist, eine gute Dokumentation hat, gut unterstützt wird und regelmässig aktualisiert wird. Gleichzeitig kann der Compiler automatisch zu einer Quantenoperation deren Inverses oder deren kontrollierte Version generieren \footnote{Siehe auch TODO Seitenzahl}, was den Code gleich kürzer und übersichtlicher macht.

Neben diesen beiden Bibliotheken finden sich im GitHub-Repository noch weitere Projekte. In einem jener Projekte ist der "Factorizer" implementiert, welcher den vollständigen  Dieser ist modular entworfen: Dem Factorizer gibt man ein Modul zum Primzahlentest und ein Modul zum berechnen der Ordnung einer Zahl mit. Diese Modularität erlaubt es, verschiedene Algorithmen miteinander zu vergleichen. Neben dem "Factorizer" sind in diesem Projekt mehrere Module implementiert. Eines jener Module benutzt dabei den quantenbasierten Teil von Shors Algorithmus und startet den Simulator, so dass dieses Modul zusammen mit dem "Factorizer" eine komplette Implementation von Shors Algorithmus bildet.

Weiterhin befindet sich im Repository auch ein Projekt für eine einfache Konsolen-Applikation, welche diese beiden "Factorizer" mit verschiedenen Modulen anwendet, als "Proof-of-Concept". Zudem gibt es auch ein Projekt für ein Zeitmesser, welcher misst, wie lange der Faktorisierer braucht.

Dazu muss ich überprüfen, ob diese Implementierungen funktionieren, deshalb habe ich drei Unit-Test-Projekte, die die verschiedenen Komponenten einzeln testen. Das Konzept der Unit-Tests erlaubt ein einfaches Lokalisieren von Implementationsfehlern und Bugs, und fangen fast alle Fehler ein.