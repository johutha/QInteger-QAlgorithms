\chapter{Einführung}
\section{Vorwort}
Das Gebiet der Quantencomputer ist aktuell zweifellos eines der vielversprechendsten Forschungsgebiete. Quantencomputer würden es uns theoretisch erlauben, Berechnungen auszuführen, die auf klassischen Computern nicht effizient\footnote{In dieser Arbeit wird ein Algorithmus als \textit{effizient} bezeichnet, wenn seine Laufzeit polynomiell in der Länge der Eingabe ist. Im Abschnitt 4.6.2 wird näher auf den Begriff der Laufzeit eines Algorithmus eingegangen.} ausgeführt werden können. Diese mathematischen Konstrukte werden in naher Zukunft mit Sicherheit eine grosse Rolle spielen. 

\paragraph{}

Immer wieder liest man in Zeitungs- und Journalartikeln über Realisierungen von Quantencomputern und immer wieder wurde von einem Durchbruch gesprochen. So zum Beispiel, als ein Forschungsteam von Google 2019 einen Artikel im Journal "`Nature"' publizierte, in welchem behauptet wurde, man habe die "`Quantenüberlegenheit"' erreicht (\cite{GSP}), was gleich darauf von der IBM in ihrem Blog angezweifelt wurde (\cite{IBM}).

\paragraph{}

In dieser Hinsicht ist es meines Erachtens ein guter Zeitpunkt, um sich vertieft mit dem Thema auseinanderzusetzen. Ich habe mich deshalb entschieden, mich auf diese Reise zu begeben und im Rahmen meiner Maturitätsarbeit zu versuchen zu verstehen, wie Quantencomputer funktionieren, um danach in einem nächsten Schritt arithmetische Operationen sowie den Shor-Algorithmus zu implementieren. Die grösste Schwierigkeit, mit der ich mich auf diesem Weg konfrontiert sah, war es, die Quantenalgorithmen zu debuggen.

In der Tat dauerte es jeweils eine Weile, bis mein Code funktionierte. Dieser war anfangs fehlerhaft und diese Fehler zu finden war eine Herausforderung. Dies lag unter anderem daran, dass Qubits komplizierte Konstrukte sind, deren momentane und geplante Zustände schwierig zu vergleichen waren. Somit konnte es Stunden in Anspruch nehmen, herauszufinden, wo sich der Fehler befand.

\paragraph{}

Rückblickend war es meiner Meinung nach nicht einfach, in dieses Gebiet einzusteigen. Meine Arbeit soll deshalb auch dazu dienen, zusammen mit der angeführten Fachliteratur anderen den Einstieg zu vereinfachen. Dazu werden allerdings Kentnisse der linearen Algebra vorausgesetzt, da diese unabdingbar sind, um die mathematische Struktur hinter den Quantensystemen zu verstehen. Zum Einstieg in die lineare Algebra habe ich das Buch "`Lineare Algebra"' von Gerd Fischer \cite{LA} studiert und empfehle dieses Buch, um sich die Grundlagen zu erarbeiten.

\paragraph{}

Ich habe mich einerseits damit auseinandergesetzt, wie arithmetische Operationen auf Quantencomputern programmiert werden können, andererseits, wie man damit Zahlen faktorisieren kann. Was ich gelernt habe, habe ich in Code umgesetzt. Ich habe zwei Programmbibliotheken implementiert, die ich in Abschnitt 1.2 genauer beschreibe und in welchen man alle in dieser Arbeit betrachteten Operationen als Code finden kann.  Zudem habe ich bei der Implementierung gezielt darauf geachtet, dass diese Bibliotheken auch in späteren Projekten gut verwendet werden können und ich habe vor, diese Bibliotheken in Zukunft kontinuierlich zu erweitern und Implementierungen anderer Quantenalgorithmen hinzuzufügen, so dass sie aktuell bleiben. 

\section{Die QInteger- und die QAlgorithm-Library und eine Implementierung des Faktorisierungsalgorithmus}
Das Produkt dieser Maturitätsarbeit sind zwei Programmbibliotheken, welche Algorithmen für Quantencomputer bereitstellen. Diese Programmbibliotheken sind in der Programmiersprache Q\# geschrieben, einer Quantenprogrammiersprache entwickelt von Microsoft. Das Quantum Development Kit (QDK) von Microsoft beinhaltet dabei nicht nur die Sprache Q\#, sondern auch einen Simulator, auf welchem man den Code ausführen kann. Gleichzeitig ist es das Ziel der Sprache, dass man sie auf echten Quantencomputern einsetzen kann, sobald diese weit genug entwickelt sein werden.
\paragraph{}
Die beiden Bibliotheken sollen mathematische Operationen auf Quantencomputern vereinfachen. Hier ein kurzer Überblick über ihre Funktionen: %TODO Besseres Wort als Funktionen
\begin{itemize}
  \item Die \textit{QInteger-Library} definiert mit dem Typ "`QInt"' die grundlegende Datenstruktur "`Zahl"' auf einem Quantencomputer. Zudem stellt sie arithmetische Operationen und nützliche Funktionen für den Typ "`QInt"' bereit. %TODO besseres Wort für zudem
  \item In der \textit{QAlgorithms-Library} sind Algorithmen für Quantencomputer implementiert, darunter auch der quantenbasierte Teil von Shors Algorithmus zur Faktorisierung von Zahlen, welcher zweifelsohne eine der nennenswertesten Errungenschaften auf dem Gebiet der Quantencomputer ist.
\end{itemize}
Die beiden Bibliotheken stellen nützliche Funktionen für Quantencomputer bereit, welche auch in anderen Projekten weiterverwendet werden können. Den Code zu diesen Programmbibliotheken kann man auf GitHub finden, wo er in Zukunft einige Aktualisierungen erfahren wird. Auf GitHub ist er unter folgendem Link verfügbar:
\paragraph{}
\centerline{ https://github.com/johutha/QInteger-QAlgorithms }
\paragraph{}
Ich habe Q\# gewählt, da es aktuell eine der populärsten Quantenprogrammiersprachen ist, über eine gute Dokumentation verfügt, gut unterstützt und regelmässig aktualisiert wird. Zudem kann der Compiler automatisch zu einer Quantenoperation ihre adjungierte oder kontrollierte Version generieren\footnote{Siehe auch 2.2.5}, was den Code kürzer und übersichtlicher macht.

\paragraph{}

Neben diesen beiden Bibliotheken findet man im GitHub-Repository weitere Projekte. In einem dieser Projekte ist der "`Factorizer"' implementiert, welcher zusammen mit den Quanten-Programmbibliotheken eine vollständige Implementierung von Shors Algorithmus bildet. Weiter sind im Projekt noch andere Faktorisierungsalgorithmen programmiert, sodass man diese miteinander vergleichen kann.

Im Weiteren befinden sich im Repository ein Projekt für eine einfache Konsolen-Applikation, welche den "`Factorizer"' benützt, sodass man diesen als Proof of Concept ausprobieren kann, und ein Projekt mit einem Zeitmesser, welcher misst, wie lange der "`Factorizer "' benötigt.

Zudem befinden sich im Repository drei weitere Projekte, in welchen Unit-Tests implementiert sind. Unit-Tests testen die verschiedenen Komponenten einzeln, wodurch man einfacher Implementierungsfehler lokalisieren und Bugs finden kann.