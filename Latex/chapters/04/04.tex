\chapter{Der Weg zu Shor}
\section{Überblick}
In diesem Kapitel werden wir uns die notwendigen Konzepte und Ideen hinter dem quantenbasierten Teil von Shors Algorithmus anschauen. Dabei starten wir beim simplen Konzept des "Phase Kickback", schauen uns dann die darauf basierende "Phase Estimation" an, bevor wir dann mit deren Hilfe die Ordnung einer Zahl finden. Zum Schluss werden wir uns dann den kompletten quantenbasierten Teil des Algorithmus zusammenfassend anschauen.
\section{Phase-Kickback}
Beginnen wir den Abschnitt mit einer Frage: Wenn wir eine kontrollierte Operation ausführen, sollte sich das Control-Qubit eigentlich nicht ändern, oder? In diesem Abschnitt werden wir sehen, dass dies überraschender Weise doch so ist. Dafür schauen wir uns das CNOT-Gatter an. Was passiert, wenn wir CNOT auf zwei Qubits im Zustand $\ket{+-}$ anwenden, mit dem ersten Qubit als Control-Qubit? Zuerst haben wir $\ket{+-} = \ket{00} - \ket{01} + \ket{10} - \ket{11}$, nachdem wir das CNOT anwenden bekommen wir den Zustand $\ket{00} - \ket{01} - \ket{10} + \ket{11} = \ket{--}$. Überraschenderweise stellen wir fest, dass sich das Control-Qubit verändert hat, während das Ziel-Qubit gleich blieb. Was ist passiert? Betrachten wir das CNOT-Gatter genauer: Das CNOT-Gatter ist nichts anderes als eine kontrollierte Version vom $X$-Gatter. Was passiert, wenn wir das $X$-Gatter auf den $\ket{-}$-Zustand anwenden? $X\ket{-} = -\ket{0} + \ket{1} = -\ket{-} = (-1)*\ket{-}$. Hier können wir sehen, dass $\ket{-}$ ein Eigenvektor des $X$-Gatters mit Eigenwert $-1$ ist. Das heisst, der Zustand des Qubits ändert sich nicht, nur die betroffenen Koeffizienten werden mit dem Eigenwert multipliziert. Da aber in diesem Fall alle Koeffizienten mit diesem Wert (mit Betrag 1) multipliziert werden, können wir keinen Unterschied feststellen.

Wenn wir aber die Operation kontrolliert durchführen, wird diese Phase nur in den Zustands sichtbar, in der die Operation durchgeführt wird, sprich in den Zustands, wo das Control-Qubit im Zustand $\ket{1}$ ist. Dies konnten wir vorher beim CNOT-Gatter beobachten. Betrachten wir nun eine allgemeinere Operation $U$ mit einem Eigenvektor $\ket{\psi}$ und dem Eigenwert $\lambda$. Nehmen wir jetzt ein Qubit $q_c$ im Zustand $\alpha\ket{0} + \beta\ket{1}$, ein Qubit-Register im Zustand $\ket{\psi}$ und führen ein kontrolliertes $U$ auf das Register $\ket{\psi}$ mit Kontroll-Qubit $q_c$ durch:
\begin{align*}
(\alpha\ket{0} + \beta\ket{1})\ket{\psi} \xrightarrow{\text{C-U}} \alpha\ket{0\psi} + \beta\ket{1}*U\ket{\psi} = (\alpha\ket{0} + \lambda\beta\ket{1})\ket{\psi}
\end{align*}
Das Ziel-Qubit verändert sich nicht, es ist ja ein Eigenvektor, dafür sehen wir, dass der Eigenwert zurück in die Phase des Kontroll-Qubit "gekickt" wird, daher der Name Phase Kickback. Im nächsten Abschnitt werden wir diesen Effekt anwenden, um den Eigenwert eines Operators abzschätzen.

\section{Phase Estimation}
Verschiedene Quanten-Algorithmen basieren darauf, den Eigenwert eines Operators zu einem Eigenvektor abzuschätzen. Dazu benutzen wir Phase-Kickbacks, um den Eigenwert in ein Quantenregister in der Fourier-Basis zu schreiben, welches wir dann mit der inversen Quanten-Fouriertransformation in die binäre Basis zurückrechnen. Dazu können wir die Anzahl Qubits variieren, um die Präzision der Approximation festlegen. Genauer gibt der Algorithmus zum Eigenwert $\lambda = e^{2i\pi\theta}$ die Zahl $2^n\theta$ zurück, wobei $n$ die Anzahl Qubits des Zählerregisters ist, die für bessere Präzision erhöht werden kann. 
\\
Um zu verstehen, wie dieser Algorithmus funktioniert, erinnern wir uns zuerst daran, wie eine Zahl in der Fourierbasis aussieht. Dafür benutzen wir die Bloch-Kugel. Wir erinnern uns, dass für die Zahl $x$ in der Fourierbasis mit $n$ Qubits das $k$-te Qubit um $\frac{2^kx}{2^n}$ um die Z-Achse gedreht wird. Das heisst, es befindet sich im Zustand $\frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi\frac{2^kx}{2^n}}\ket{1})$. Wir machen jetzt die Beobachtung, dass wir mit Hilfe von Phase-Kickback das gesuchte $\theta$ in der Fourierbasis in die Kontrollqubits schreiben können, da der Phase-Kickback nichts anderes macht, als das Kontrollqubit auf die selbe Art und Weise zu rotieren. Schauen wir uns mal an, was passert, wenn wir $2^k$ mal das kontrollierte $U$ anwenden:
\begin{align*}
\frac{1}{\sqrt{2}}(\ket{0} + \ket{1})\ket{\psi} \xrightarrow{(C-U)^{2^k}} \frac{1}{\sqrt{2}}(\ket{0\psi} + \ket{1}*U^{2^k}\ket{\psi}) \\ = \frac{1}{\sqrt{2}}(\ket{0} + (e^{2i\pi\theta})^{2^k}\ket{1})\ket{\psi} \\
= \frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi2^k\theta}\ket{1})\ket{\psi} \\
= \frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi\frac{2^k(2^n\theta)}{2^n}}\ket{1})\ket{\psi}
\end{align*}
Dies entspricht genau dem $k$-ten Qubit der Repräsentation von $2^n\theta$ in der Fourierbasis. Das heisst, wenn wir für jedes Qubit im Zählerregister mehrmals ein kontrolliertes $U$ anwenden, können wir einen Zustand kreieren, welcher der Zahl $2^n\theta$ in der Fourierbasis entspricht. Wenden wir dann die inverse Fouriertransformation an, können wir die Zahl $2^n\theta$ im Zählerregister ablesen. Falls $2^n\theta$ keine ganze Zahl ist, dann bekommen wir im Zählerregister eine Superposition, wobei eine Zahl wahrscheinlicher ist, je näher sie am echten Wert ist.

Um die Phase abzuschätzen, müssen wir also den Operator mehrmals hintereinander anwenden, zuerst nur einmal, dann zweimal, im $i$-ten Mal $2^i$ mal. Dies führt dazu, dass wir die Operation $2^n$ mal anwenden müssen. Allerdings ist es oft möglich, dass wir die Operation $U^{2^m}$ für einen beliebigen Parameter $m$ implementieren können. Wenn dies möglich ist, dann brauchen wir nur $n$ Anwendungen jener Operation.

\paragraph{Algorithmus}
\begin{enumerate}
    \item Initialisiere zwei Quantenregister, das Zählerregister und das EigenZustand-Register, und setze das EigenZustand-Register auf den gewünschten EigenZustand $\psi$.
    \item Wende $H^{\otimes n}$ auf das Zähler-Register an, um es auf $\ket{+}^{\otimes n}$ zu setzen.
    \item Für das $i$-te Bit im Zählerregister, wende ein kontrolliertes $U^{2^i}$ mit $c_i$ als Kontroll-Qubit an.
    \item Wende die inverse Quantenfouriertransformation auf das Zählerregister an, um die Approximation in die binäre Basis umzurechnen.
    \item Miss das Zählerregister, um die Abschätzung abzulesen.
\end{enumerate}
\input{./assets/circuits/4.3.1.crct} \newline

\section{Period Finding}
Gegeben sei eine Funktion $f : S \rightarrow S$ mit $S \subset \mathbb{Z}$, welche sich auf einem Quantencomputer implementieren lässt, und ein Wert $x \in S$. Wir versuchen nun, die kleinste Zahl $r \in \mathbb{N}$ zu berechnen, so dass $f^r(x) = x$ gilt.

Unsere Funktion soll auf einem Quantencomputer implementierbar sein. Daraus folgt bereits, dass $f$ bijektiv ist: Falls es ein $a$ und ein $b$ mit $f(a) = f(b) = c$ gibt, dann lässt sich $f^{-1}(c)$ nicht berechnen, was im Wiederspruch zur Reversibilität steht. Daraus folgt, dass $f$ injektiv ist. Deshalb müssen $|S|$ verschiedene Funktionswerte von $f$ existieren, woraus die Surjektivität folgt. Somit ist $f$ bijektiv und man kann $f$ als Permutation der Elemente von $S$ interpretieren. Diese Permutation kann als Vereinigung disjunkter Zyklen zerlegen.
Dies bedeutet, dass man $S$ in verschiedene Teilmengen $S_0, S_1, ...$ aufteilen kann, so dass jede dieser Teilmengen ein einzelner Zyklus der Permutation bildet.
Sei nun $x \in S_i$. Da $S_i$ ein Zyklus bildet, gilt $f^{|S_i|}(x) = x$. Gleichzeitig kann kein $r \in \mathbb{N}$ mit $r < |S_i|$ existieren, so dass $f^r(x) = x$ gilt, denn sonst hätte unser Zyklus nur $r < |S_i|$ Elemente. Wir wollen nun also für ein $x \in S_i$ die Grösse $|S_i|$ finden.

Als Beispiel nehmen wir mal $g : A \rightarrow A$ mit $A = \mathbb{Z}/11\mathbb{Z}$, $g(x) = -x^3 + 1$. Man kann zeigen, dass $x^3 \pmod{p}$ bijektiv ist, falls $p \equiv 2 \pmod 3$. Somit ist auch $f$ bijektiv. Wenn wir den Graphen anschauen, dann sehen wir die einzelnen Zyklen: $A_0 = \{0, 1\}$, $A_1 = \{2, 3, 4, 7, 10\}$, $A_2 = \{5, 6, 8\}$ und $A_3 = \{9\}$. Wir sehen nun, dass $f^1(9) = 9$, $f^3(8) = 8$, $f^5(2) = 2$ etc. 

TODO Beispiel $f : \mathbb{Z} / 11 \mathbb{Z} \rightarrow \mathbb{Z} / 11 \mathbb{Z} $, $f(x) = -x^3 + 1$
\input{./assets/graphs/4.4.1.grph}

Die Frage ist nun, wie können wir effizient die Grösse der Teilmenge finden, in der $x$ sich befindet. Dafür müssen wir den Operator $f$ genauer betrachten. Was passiert, wenn wir dem Operator eine Superposition der Zahlen in $S_i$ übergeben? Seien $r = |S_i|$, $x_0, x_1, ..., x_{r - 1}$ die Zahlen in $S_i$, so dass $f(x_j) = x_{(j + 1) \% r}$, und $U_f$ die Quantenoperation, die $f$ implementiert. Schauen wir mal, was passiert, wenn wir $U_f$ auf den Zustand $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j}$ anwenden? Wir bekommen:
\begin{align*}
    U_f(\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j}) = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{f(x_j)} = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_{(j + 1) \% r}} = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j})
\end{align*}
Daraus schliessen wir, dass $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j}$ ein EigenZustand von $U_f$ mit Eigenwert $1$ ist. Dieser Eigenwert ist nicht wirklich interessant. Wir können ihn aber interessanter machen, indem wir den einzelnen Summanden eine Phase mitgeben. Dazu konstruieren wir die Superposition $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})$ für ein $k < r$. Was passiert, wenn wie $U_f$ darauf anwenden? 
\begin{align*}
    U_f(\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})) = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_{(j + 1) \% r}}) = \\
    \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{k(j - 1)}{r}}\ket{x_j}) = e^{2i\pi\frac{k}{r}}(\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j}))
\end{align*}
Auch hier haben wir wieder einn Eigenvektor, aber mit einem interessanterem Eigenwert, nämlich $e^{2i\pi\frac{k}{r}}$, denn $r$ ist im Eigenwert enthalten. Wir machen auch die Beobachtung, dass unser EigenZustand von vorher ($\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j}$) auch von der Form ist, die wir gerade analysiert haben, einfach mit $k = 0$. Falls wir jetzt irgendwie einen Zustand von der Form $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})$ erzeugen können, könnten wir mit Hilfe der Phase Estimation den Quotienten $\frac{k}{r}$ abschätzen. Die Frage ist, wie können wir solch einen Zustand generieren? Zuerst sagen wir, $\ket{\psi_k}$ sei $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})$. Dann stellen wir fest, dass $\ket{\psi_0}, \ket{\psi_1}, ..., \ket{psi_{r - 1}}$ linear unabhängig und damit eine Basis des Untervektorraums über die Zahlen $x_0, x_1, ..., x_{r - 1}$ sind. Was passiert nun, wenn wir alle diese Vektoren mit gleichem Gewicht aufsummieren?
\begin{align*}
    \frac{1}{\sqrt{r}}\sum_{k = 0}^{r - 1}\frac{1}{\sqrt{r}}(\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})) = \frac{1}{r}\sum_{j = 0}^{r - 1}\sum_{k = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j}) = \ket{x_0}
\end{align*}
Eine andere Art, dieses überraschende Resultat zu sehen, ist, dass man die Summe $\sum_{k = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})$ für $j = 0$ anzuschauen. Da $j = 0$ gilt, gilt $e^{-2i\pi\frac{kj}{r}} = e^{0} = 1$ und somit $\sum_{k = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j}) = r\ket{x_j}$. Da $\frac{1}{r}(r\ket{x_j})$ bereits einen Betrag von $1$ hat, kann kein anderer Zustand mit positivem Betrag existieren, da die Beträge sich sonst zu etwas Grösserem als $1$ aufsummieren.

Somit ist $x_0$ einfach eine Superposition jener Eigenvektoren. Da wir der Periodenabschätzungsfunktion einen Startwert mitgeben, sei jener Startwert WLOG $x_0$, haben wir eine Superposition dieser Eigenvektoren. Schätzen wir somit den Eigenwert dieser Superposition ab, kollabiert sie in eine der Eigenvektoren, und wir bekommen einen Quotienten $\frac{k}{r}$ zurück, wobei jedes $k$ die gleiche Wahrscheinlichkeit hat. Genauer, bekommen wir die Zahl $2^n\frac{k}{r}$ zurück, wobei $n$ die Präzision ist, die wir dem Phase Estimation-Algorithmus mitgeben. Wir können mit Hilfe von Kettenbrüchen den Quotienten $\frac{k}{r}$ vom Quotienten $\frac{2^n\frac{k}{r}}{2^n}$ abschätzen. Sobald wir den Bruch $\frac{k}{r}$ haben, wissen wir $r$, was die Zahl ist, die unsere Funktion zurückgeben soll. Nun kann es sein, dass $ggT(k, r) = g \neq 1$ ist, somit der Bruch mit $g$ gekürzt wird und wir dann als Resultat $\frac{r}{g}$ bekommen. Wenn wir die Prozedur aber $2log(N)$ mal wiederholen, bekommen wir mit sehr hoher Wahrscheinlichkeit mindestens einmal die korrekte Periode. Den Beweis dazu kann man in [QC], Seiten 229ff., nachlesen.

\section{Die Ordnung von Zahlen bestimmen}
Der Algorithmus von Shor ist deshalb so schnell, da mit Hilfe des quantenbasierten Teils des Algorithmus die Ordnung einer Zahl schnell bestimmt werden kann. Sei $a$ die Zahl deren Ordnung wir Modulo der Zahl $n$ bestimmen wollen, so dass $ggT(a, n) = 1$.  Wir rechnen nun in $\mathbb{Z} / n \mathbb{Z}$. Da $ord_n(a)$ nichts anderes ist als die Periode der Funktion $g(x) = a^x$. Somit können wir die Funktion $f(x) = ax$ implementieren, so dass $f_s(x) = f^x(s) = sa^x$. Mit $s = 1$ bekommen wir dann $f_1(x) = f^x(1) = a^x$. Sei $U$ die Quantenoperation, die $f_1$ implementiert, dafür können wir einfach die Multiplikation aus der QInteger-Library verwenden. Gleichzeitig können wir auch $U^{2^i}$ effizient implementieren: $U^{2^i}$ ist nichts anderes als die Operation zu $f^{2^i}$. Da $f^{2^i}(x) = a^{2^i}x$, können wir ganz einfach $a^{2^i}$ klassisch berechnen und dann wieder die gewöhnliche Multiplikation aus der QInteger-Library verwenden. Wir können nun den Algorithmus aus dem vorherigen Kapitel verwenden, um die Periode der Funktion $f_1(x) = a^x$ abzuschätzen. Wir brauchen dafür nur noch eine Funktion, die $f(x) = a^x$ klassisch berechnet, um das Resultat überprüfen zu können, dafür kann man fast direkt FastPowMod aus der QInteger-Library verwenden. Dies führt dazu, dass der Code dieser Funktion nur sehr kurz ist.

\section{Das Ziel - Shors Algorithmus}
Wie erlaubt uns das nun, Zahlen zu faktorisieren? Sei $n$ die zu faktorisierende Zahl. Zuerst überprüfen wir, ob die Zahl durch 2 teilbar oder eine Primpotenz ist, und finden diese Faktoren entsprechend. Nun nehmen wir ein zufälliges $1 < a < n$. Falls $g = ggT(a, n) \neq 1$, dann haben wir bereits einen Teiler gefunden, nämlich $g$. Sonst sind $a$ und $n$ teilerfremd. Danach suchen wir die Ordnung von $a$ modulo $n$. Falls diese Ordnung ungerade ist, beginnen wir nochmals von vorne, sonst ist sie gerade. Sei diese Ordnung $r$. Mit $r$ können wir nun mit gewisser Wahrscheinlichkeit einen Teiler finden. Falls $a^{\frac{r}{2}} \not\equiv -1 \pmod n$ gilt, dann haben wir eine Wurzel von $1 \pmod{n}$ gefunden, sonst müssen wir es nochmals probieren. Da $r$ die Ordnung von $a$ ist, muss $a^{\frac{r}{2}}\not\equiv 1 \pmod{n}$ gelten. Nun gilt: $n | (a^\frac{r}{2} + 1)(a^\frac{r}{2} - 1)$, aber $n \not| \; a^\frac{r}{2} + 1$ und $n \not| \; a^\frac{r}{2} - 1$. Wir haben nun zwei Zahlen $b$ und $c$, sodass $n | bc$, aber $n \not | \; b$ und $n \not | \; c$. Sei $n = p_0^{\alpha_0}p_1^{\alpha_1}...$. Schreibe nun $b = s_bp_0^{\beta_0}p_1^{\beta_1}...$ und $b = s_cp_0^{\gamma_0}p_1^{\gamma_1}...$. Wir wissen nun, dass $\beta_i + \gamma_i \geq \alpha_i$ gelten muss, da sonst $n | bc$ nicht erfüllt wäre. Gleichzeitig müssen ein $j_b$ und ein $j_c$ existieren, so dass $\beta_{j_b} > 0$ und $\gamma_{j_c} > 0$ stimmt. Nehme an, dass ohne Beschrünkung der Allgemeinheit $\gamma_i = 0$ für alle $i$ gelte. Dann müsste $\beta_i \geq \alpha_i$ für alle $i$ gelten, und somit $n | b$ teilen, was ein Widerspruch zur Annahme $n \not | \; b$ wäre. Somit beinhalten beide Faktoren $b$ und $c$ Teiler von $n$, welche mit dem einfachen $ggT$-Algorithmus extrahiert werden können. Somit kennen wir nun den ganzen Algorithmus, um einen Teiler von $n$ zu finden.
\begin{enumerate}
    \item Falls $n$ durch zwei teilbar ist, gib 2 zurück und terminiere.
    \item Falls $n = p^a$ eine Primpotenz ist, gib die Primzahl $p$ zurück und terminiere.
    \item Bestimme eine zufällige Zahl $1 < a < n - 1$.
    \item Finde $g = ggT(a, n)$. Falls $g \neq 1$ ist, gib $g$ zurück und terminiere.
    \item Bestimme die Ordnung von $a$ modulo $n$ mit Hilfe des Quantenteils des Algorithmus:
    \begin{enumerate}
        \item Schätze die Phase des Operators $U_f$ ab, der $f(x) = ax$ implementiert mit einer Präzision von $m = 2\log_2(n)$ ab. Benutze dazu den in Kapitel 4.3 vorgestellten Algorithmus. Sei das Resultat $2^m\lambda$.
        \item Schätze den Quotienten $\frac{k}{r}$ von $\frac{2^m\lambda}{2^m}$ ab. Falls $r$ nicht die gesuchte Periode ist, gehe zurück zu (a), sonst gib die Periode $r$ zurück.
    \end{enumerate}
    \item Falls $r$ ungerade ist, gehe zurück zu 2. Sonst berechne $a^{r / 2} \pmod{n}$. Falls dies kongruent zu $-1 \pmod{n}$ ist, gehe zurück zu 2.
    \item Berechne $b = (a^\frac{r}{2} + 1)$. Gib $ggT(b, n)$ zurück und terminiere.
\end{enumerate}