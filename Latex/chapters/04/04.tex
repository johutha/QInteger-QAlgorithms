\chapter{Der Weg zu Shor}
\section{Überblick}
In diesem Kapitel werden wir uns die notwendigen Konzepte und Ideen hinter dem quantenbasierten Teil von Shor's Algorithmus anschauen. Dabei starten wir beim simplen Konzept des "Phase Kickback"s, schauen uns dann die darauf basierende Phase Estimation an, bevor wir dann deren Anwendung in Period Finding anschauen. Zum Schluss werden wir uns dann die komplette Implementation vom quantenbasierten Teil von Shors Algorithmus anschauen und überprüfen.
\section{Phase-Kickback}
Beginnen wir den Abschnitt mit einer Frage: Wenn wir eie kontrollierte Operation ausführen, sollte sich das Control-Qubit eigentlich nicht ändern, oder? In diesem Abschnitt werden wir sehen, dass dies überraschender Weise nicht so ist. Dafür schauen wir uns das CNOT-Gate an. Was passirt, wenn wir CNOT auf zwei Qubits im State $\ket{+-}$ anwenden, mit dem ersten Qubit als Control-Qubit? Zuerst haben wir $\ket{+-} = \ket{00} - \ket{01} + \ket{10} - \ket{11}$, nachdem wir das CNOT anwenden bekommen wir den State $\ket{00} - \ket{01} - \ket{10} + \ket{11} = \ket{--}$. Überraschenderweise stellen wir fest, dass sich das Control-Qubit verändert hat, während das Ziel-Qubit gleich blieb. Was ist passiert? Nehmen wir das CNOT-Gate auseinander: Das CNOT-Gate ist eigentlich nichts anderes als eine kontrollierte Version vom $X$-Gate. Was passiert wenn wir das $X$-Gate auf den $\ket{-}$-State anwenden? $X\ket{-} = -\ket{0} + \ket{1} = -\ket{-} = (-1)*\ket{-}$. Hier können wir sehen, dass $\ket{-}$ ein Eigenvektor des $X$-Gates mit Eigenwert $-1$. Das heisst, der State des Qubits ändert sich nicht, es wird nur die Phase mit dem Eigenwert multipliziert. Da wir nur ein einzelnes Qubit anschauen, hat das keine Auswirkung, da die Phase global ist und wir dehalb keinen Unterschied feststellen können. Wenn wir aber die Operation kontrolliert durchführen, wird diese Phase nur in den States sichtbar, in der die Operation durchgeführt wird, sprich in den States, wo das Control-Qubit im State $\ket{1}$ ist. Dies konnten wir vorher beim CNOT-Gate beobachten. Schauen wir uns nun mal ein generelleres Gate an. Sagen wir, wir nehmen das Gate $U$ mit einem Eigenvektor $\ket{\psi}$ und dem Eigenwert $\lambda$. Nehmen wir jetzt ein Qubit $q_c$ im State $\alpha\ket{0} + \beta\ket{1}$, $n$ Qubits $q_0 ... q_{n-1}$ im State $\ket{\psi}$, und führen ein kontrolliertes $U$ auf die Qubits $q_0 ... q_{n-1}$ mit Kontroll-Qubit $q_c$, ergibt sich:
\begin{align*}
\alpha\ket{0}\ket{\psi} + \beta\ket{1}\ket{\psi} \xrightarrow{\text{C-U}} \alpha\ket{0}\ket{\psi} + \beta\ket{1}*U\ket{\psi} = \alpha\ket{0}\ket{\psi} + \lambda\beta\ket{1}\ket{\psi}
\end{align*}
Das Ziel-Qubit verändert sich nicht, es ist ja ein Eigenvektor, dafür sehen wir, dass der Eigenwert in die Phase des Kontroll-Qubit gekickt wird. Daher kommt der Name "Phase Kickback". Wir werden in der nächsten Sektion sehen, wie dieser Effekt ausgenutz werden kann, um den Eigenwert eines Operators abzuschätzen.

\section{Phase Estimation}
Verschiedene Quanten-Algorithmen basieren darauf, den Eigenwert eines Operators zu einem Eigenvektor abzuschätzen. Dazu benutzen wir Phase-Kickbacks, um den Eigenwert in ein Quantum-Register in der Fourier-Basis zu schreiben, welches wir dann mit der inversen Quanten-Fouriertransformation in die binäre Basis zurückrechnen. Dazu können wir die Anzahl Qubits variieren, um die Präzision der Approximation festlegen. Besser gesagt gibt der Algorithmus zum Eigenwert $\lambda = e^{2i\pi\theta}$ die Zahl $\lfloor{2^n\theta}\rfloor$ zurück, wobei $n$ die Anzahl Qubits des Zählerregisters ist, die für bessere Präzision erhöht werden kann. 
\paragraph{Algorithmus}\mbox{} \newline
\input{./circuits/4.3.1.crc}