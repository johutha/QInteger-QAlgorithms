\chapter{Der Weg zu Shor}
\section{Überblick}
In diesem Kapitel werden wir uns die notwendigen Konzepte und Ideen hinter dem quantenbasierten Teil von Shor's Algorithmus anschauen. Dabei starten wir beim simplen Konzept des "Phase Kickback"s, schauen uns dann die darauf basierende Phase Estimation an, bevor wir dann deren Anwendung in Period Finding anschauen. Zum Schluss werden wir uns dann die komplette Implementation vom quantenbasierten Teil von Shors Algorithmus anschauen und überprüfen.
\section{Phase-Kickback}
Beginnen wir den Abschnitt mit einer Frage: Wenn wir eie kontrollierte Operation ausführen, sollte sich das Control-Qubit eigentlich nicht ändern, oder? In diesem Abschnitt werden wir sehen, dass dies überraschender Weise nicht so ist. Dafür schauen wir uns das CNOT-Gate an. Was passirt, wenn wir CNOT auf zwei Qubits im State $\ket{+-}$ anwenden, mit dem ersten Qubit als Control-Qubit? Zuerst haben wir $\ket{+-} = \ket{00} - \ket{01} + \ket{10} - \ket{11}$, nachdem wir das CNOT anwenden bekommen wir den State $\ket{00} - \ket{01} - \ket{10} + \ket{11} = \ket{--}$. Überraschenderweise stellen wir fest, dass sich das Control-Qubit verändert hat, während das Ziel-Qubit gleich blieb. Was ist passiert? Nehmen wir das CNOT-Gate auseinander: Das CNOT-Gate ist eigentlich nichts anderes als eine kontrollierte Version vom $X$-Gate. Was passiert wenn wir das $X$-Gate auf den $\ket{-}$-State anwenden? $X\ket{-} = -\ket{0} + \ket{1} = -\ket{-} = (-1)*\ket{-}$. Hier können wir sehen, dass $\ket{-}$ ein Eigenvektor des $X$-Gates mit Eigenwert $-1$. Das heisst, der State des Qubits ändert sich nicht, es wird nur die Phase mit dem Eigenwert multipliziert. Da wir nur ein einzelnes Qubit anschauen, hat das keine Auswirkung, da die Phase global ist und wir dehalb keinen Unterschied feststellen können. Wenn wir aber die Operation kontrolliert durchführen, wird diese Phase nur in den States sichtbar, in der die Operation durchgeführt wird, sprich in den States, wo das Control-Qubit im State $\ket{1}$ ist. Dies konnten wir vorher beim CNOT-Gate beobachten. Schauen wir uns nun mal ein generelleres Gate an. Sagen wir, wir nehmen das Gate $U$ mit einem Eigenvektor $\ket{\psi}$ und dem Eigenwert $\lambda$. Nehmen wir jetzt ein Qubit $q_c$ im State $\alpha\ket{0} + \beta\ket{1}$, $n$ Qubits $q_0 ... q_{n-1}$ im State $\ket{\psi}$, und führen ein kontrolliertes $U$ auf die Qubits $q_0 ... q_{n-1}$ mit Kontroll-Qubit $q_c$ durch:
\begin{align*}
(\alpha\ket{0} + \beta\ket{1})\ket{\psi} \xrightarrow{\text{C-U}} \alpha\ket{0\psi} + \beta\ket{1}*U\ket{\psi} = (\alpha\ket{0} + \lambda\beta\ket{1})\ket{\psi}
\end{align*}
Das Ziel-Qubit verändert sich nicht, es ist ja ein Eigenvektor, dafür sehen wir, dass der Eigenwert in die Phase des Kontroll-Qubit gekickt wird. Daher kommt der Name "Phase Kickback". Wir werden in der nächsten Sektion sehen, wie dieser Effekt ausgenutz werden kann, um den Eigenwert eines Operators abzuschätzen.

\section{Phase Estimation}
Verschiedene Quanten-Algorithmen basieren darauf, den Eigenwert eines Operators zu einem Eigenvektor abzuschätzen. Dazu benutzen wir Phase-Kickbacks, um den Eigenwert in ein Quantum-Register in der Fourier-Basis zu schreiben, welches wir dann mit der inversen Quanten-Fouriertransformation in die binäre Basis zurückrechnen. Dazu können wir die Anzahl Qubits variieren, um die Präzision der Approximation festlegen. Besser gesagt gibt der Algorithmus zum Eigenwert $\lambda = e^{2i\pi\theta}$ die Zahl $2^n\theta$ zurück, wobei $n$ die Anzahl Qubits des Zählerregisters ist, die für bessere Präzision erhöht werden kann. 
\\
Um zu verstehen, wie dieser Algorithmus funktioniert, erinnern wir uns zuerst nochmals, wie eine Zahl in der Fourierbasis aussieht. Dafür benutzen wir nochmals die Bloch-Kugel. Wir erinnern uns, dass für die Zahl $x$ in der Fourierbasis mit $n$ Qubits das $k$-te Qubit um $\frac{2^kx}{2^n}$ um die Z-Achse gedreht wird. Das heisst, es befindet sich im Zustand $\frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi\frac{2^kx}{2^n}}\ket{1})$. Wir machen jetzt die Beobachtung, dass wir mit Hilfe von Phase-Kickback das gesuchte $\theta$ in der Fourierbasis in die Kontrollqubits schreiben können, da der Phase-Kickback nichts anderes macht, als das Kontrollqubit auf die selbe Art und Weise zu rotieren. Schauen wir uns mal an, was passert, wenn wir das kontrollierte $U$ $2^k$ mal anwenden:
\begin{align*}
\frac{1}{\sqrt{2}}(\ket{0} + \ket{1})\ket{\psi} \xrightarrow{(C-U)^{2^k}} \frac{1}{\sqrt{2}}(\ket{0\psi} + \ket{1}*U^{2^k}\ket{\psi}) \\ = \frac{1}{\sqrt{2}}(\ket{0} + (e^{2i\pi\theta})^{2^k}\ket{1})\ket{\psi} \\
= \frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi2^k\theta}\ket{1})\ket{\psi} \\
= \frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi\frac{2^k(2^n\theta)}{2^n}}\ket{1})\ket{\psi}
\end{align*}
Dies entspricht genau dem $k$-ten Qubit der Repräsentation von $2^n\theta$ in der Fourierbasis. Das heisst, wenn wir für jedes Qubit im Zählerregister mehrmals ein kontrolliertes $U$ anwenden, können wir einen Zustand kreieren, welcher der Zahl $2^n\theta$ in der Fourierbasis entspricht. Wenden wir dann die inverse Fouriertransformation an, können wir die Zahl $2^n\theta$ im Zählerregister ablesen. Falls $2^n\theta$ keine ganze Zahl ist, dann bekommen wir im Zählerregister eine Superposition, wobei eine Zahl wahrscheinlicher ist, je näher sie am echten Wert ist.

\paragraph{Algorithmus}
\begin{enumerate}
    \item Initialisiere zwei Quantenregister, das Zählerregister und das Eigenstate-Register, und setze das Eigenstate-Register auf den gewünschten Eigenstate $\psi$.
    \item Wende $H^{\otimes n}$ auf das Zähler-Register an, um es auf $\ket{+}^{\otimes n}$ zu setzen.
    \item Für das $i$-te Bit im Zählerregister, wende das kontrollierte $U$ mit $c_i$ als Kontroll-Qubit $2^i$ Mal auf den Eigenstate an.
    \item Wende die inverse Quantenfouriertransformation auf das Zählerregister an, um die Approximation in die binäre Basis umzurechnen.
    \item Miss das Zählerregister, um die Abschätzung abzulesen.
\end{enumerate}
\input{./assets/circuits/4.3.1.crct} \newline

\section{Period Finding}
Gegeben sei eine Funktion $f : S \rightarrow S$ mit $S \subset \mathbb{Z}$, welche sich auf einem Quantencomputer implementieren lässt, und ein Wert $x \in S$. Wir versuchen nun, die kleinste Zahl $r \in \mathbb{N}$ zu berechnen, so dass $f^r(x) = x$ gilt. In anderen Worten: Sei $f_x(i) = f^i(x)$. Wir wollen nun die Periode von $f_x$ zu berechnen.

Wir haben gesagt, unsere Funktion soll auf einem Quantencomputer implementierbar sein. Daraus folgt bereits, dass $f$ bijektiv ist: Falls es ein $a$ und ein $b$ mit $f(a) = f(b) = c$ gibt, dann lässt sich $f^{-1}(c)$ nicht berechnen, was im Wiederspruch zur Reversibilität steht. Daraus folgt, dass $f$ injektiv ist. Gleichzeitig müssen deshalb $|S|$ verschiedene Bilder von $f$ existieren, damit jeder Wert ein eigenes Bild hat. Unsere Funktion permutiert die Elemente in $S$. Schaut man sich diese Permutation als Graph an, so hat jeder Knoten einen Eingangs- und einen Ausgangsgrad von 1. Dies ist jedoch nur möglich, wenn der Graph eine Vereinigung disjunkter Zyklen ist.
Dies bedeutet auch, dass man $S$ in verschiedene Teilmengen $S_0, S_1, ...$ aufteilen kann, so dass jede dieser Teilmengen ein einzelner Zyklus des Graphen bildet.
Sei nun $x \in S_i$. Da $S_i$ ein Zyklus bildet, gilt $f^{|S_i|}(x) = x$. Gleichzeitig kann kein $r \in \mathbb{N}$ mit $r < |S_i|$ existieren, so dass $f^r(x) = x$ gilt, denn sonst hätte unser Zyklus nur $r < |S_i|$ Elemente. Wir wollen nun also für ein $x \in S_i$ die Grösse $|S_i|$ finden.

Als Beispiel nehmen wir mal $g : A \rightarrow A$ mit $A = \mathbb{Z}/11\mathbb{Z}$, $g(x) = -x^3 + 1$. Man kann zeigen, dass $x^3 \pmod{p}$ bijektiv ist, falls $p \equiv 2 \pmod 3$. Somit ist auch $f$ bijektiv. Wenn wir den Graphen anschauen, dann sehen wir die einzelnen Zyklen: $A_0 = \{0, 1\}$, $A_1 = \{2, 3, 4, 7, 10\}$, $A_2 = \{5, 6, 8\}$ und $A_3 = \{9\}$. Wir sehen nun, dass $f^1(9) = 9$, $f^3(8) = 8$, $f^5(2) = 2$ etc. 

TODO Beispiel $f : \mathbb{Z} / 11 \mathbb{Z} \rightarrow \mathbb{Z} / 11 \mathbb{Z} $, $f(x) = -x^3 + 1$
\input{./assets/graphs/4.4.1.grph}

Die Frage ist nun, wie können wir effizient die Grösse der Teilmenge finden, in der $x$ sich befindet. Dafür müssen wir den Operator $f$ genauer betrachten. Was passiert, wenn wir dem Operator eine Superposition der Zahlen in $S_i$ übergeben? Seien $r = |S_i|$, $x_0, x_1, ..., x_{r - 1}$ die Zahlen in $S_i$, so dass $f(x_j) = x_{(j + 1) \% r}$, und $U_f$ die Quantenoperation, die $f$ implementiert. Schauen wir mal, was passiert, wenn wir $U_f$ auf den Zustand $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j}$ anwenden? Wir bekommen:
\begin{align*}
    U_f(\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j}) = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{f(x_j)} = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_{(j + 1) \% r}} = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j})
\end{align*}
Daraus schliessen wir, dass $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j})$ ein Eigenstate von $U_f$ mit Eigenwert $1$ ist. Dieser Eigenwert ist nicht wirklich interessant. Wir können ihn aber interessanter machen, indem wir den einzelnen Summanden eine Phase mitgeben. Dazu konstruieren wir die Superposition $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})$ für ein $k < r$. Was passiert, wenn wie $U_f$ darauf anwenden? 
\begin{align*}
    U_f(\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})) = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_{(j + 1) \% r}}) = \\
    \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{k(j - 1)}{r}}\ket{x_j}) = e^{2i\pi\frac{k}{r}}(\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j}))
\end{align*}
Auch hier haben wir wieder einn Eigenvektor, aber mit einem interessanterem Eigenwert, nämlich $e^{2i\pi\frac{k}{r}}$, denn $r$ ist im Eigenwert enthalten. Wir machen auch die Beobachtung, dass unser Eigenstate von vorher ($\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j}$) auch von der Form ist, die wir gerade analysiert haben, einfach mit $k = 0$. Falls wir jetzt irgendwie einen State von der Form $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})$ erzeugen können, könnten wir mit Hilfe der Phase Estimation der Quotient $\frac{k}{r}$ abschätzen. Die Frage ist, wie können wir solch einen State generieren? 