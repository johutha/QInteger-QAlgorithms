\chapter{Der Weg zum Shor-Algorithmus}
\section{Überblick}
In diesem Kapitel werden wir uns die notwendigen Konzepte und Ideen hinter dem quantenbasierten Teil des Shor-Algorithmus anschauen. Dabei beginnen wir beim simplen Konzept des \grqq Phase Kickback\grqq{} , schauen uns dann die darauf basierende \grqq Phase Estimation\grqq{} an, bevor wir mit deren Hilfe die Ordnung einer Zahl finden. Zum Schluss werden wir uns den kompletten quantenbasierten Teil des Algorithmus zusammenfassend anschauen.
\section{Phase Kickback}
Beginnen wir den Abschnitt mit einer Frage: Wenn wir eine kontrollierte Operation ausführen, sollte sich das Control-Qubit eigentlich nicht ändern, oder? In diesem Abschnitt werden wir sehen, dass dies überraschenderweise doch so sein kann. Dafür schauen wir uns das CNOT-Gatter an. Was geschieht, wenn wir CNOT auf zwei Qubits im Zustand $\ket{+-}$ anwenden, mit dem ersten Qubit als Control-Qubit? Zuerst haben wir $\ket{+-} = \frac{1}{2}(\ket{00} - \ket{01} + \ket{10} - \ket{11})$. Nachdem wir das CNOT anwenden, bekommen wir den Zustand $\frac{1}{2}(\ket{00} - \ket{01} - \ket{10} + \ket{11}) = \ket{--}$. Überraschenderweise stellen wir fest, dass sich das Control-Qubit verändert hat, während das Ziel-Qubit gleich blieb. Was ist passiert? Betrachten wir das CNOT-Gatter genauer: Das CNOT-Gatter ist nichts anderes als eine kontrollierte Version des $X$-Gatters. Was geschieht, wenn wir das $X$-Gatter auf den $\ket{-}$-Zustand anwenden? $X\ket{-} = -\ket{0} + \ket{1} = -\ket{-} = (-1)*\ket{-}$. Hier können wir sehen, dass $\ket{-}$ ein Eigenvektor des $X$-Gatters mit Eigenwert $-1$ ist. Der Zustand ändert sich somit bis auf einen globalen Faktor nicht, den wir - wie in 2.2.2 erklärt wurde - nicht durch eine Messung unterscheiden können.

\paragraph{}

Wenn wir hingegen die Operation kontrolliert durchführen, wird diese Phase nur in den Zuständen sichtbar, in welchen die Operation durchgeführt wurde, sprich in den Zuständen, in denen das Control-Qubit im Zustand $\ket{1}$ ist. Dies konnten wir zuvor beim CNOT-Gatter beobachten. Betrachten wir nun eine allgemeinere Operation $U$ mit einem Eigenvektor $\ket{\psi}$ und dem Eigenwert $\lambda$. Nehmen wir jetzt ein Kontrollqubit im Zustand $\alpha\ket{0} + \beta\ket{1}$, ein Qubit-Register im Zustand $\ket{\psi}$ und wenden $U$ auf das Register $\ket{\psi}$ an, kontrolliert durch jenes Kontrollqubit:
\begin{align*}
(\alpha\ket{0} + \beta\ket{1})\ket{\psi} \xrightarrow{U^c} \alpha\ket{0\psi} + \beta\ket{1}*U\ket{\psi} = (\alpha\ket{0} + \lambda\beta\ket{1})\ket{\psi}
\end{align*}
Das Ziel-Qubit verändert sich nicht, es ist ja ein Eigenvektor, stattdessen sehen wir, dass der Eigenwert zurück in die Phase des Kontrollqubit \grqq gekickt\grqq{} wird, daher der Name \grqq Phase Kickback\grqq{}. Im nächsten Abschnitt werden wir diesen Effekt anwenden, um den Eigenwert eines Operators abzschätzen.

\section{Phasenabschätzung}
Verschiedene Quanten-Algorithmen basieren darauf, den Eigenwert eines Operators zu einem Eigenvektor abzuschätzen. Dazu benutzen wir Phase-Kickbacks, um den Eigenwert in ein Zähler-register in der Fourier-Basis zu schreiben, welches wir dann mit der inversen Quantenfourier-transformation in die binäre Basis zurückrechnen. Dazu können wir die Anzahl Qubits variieren, um die Präzision der Approximation festlegen. Genauer gibt der Algorithmus zum Eigenwert $\lambda = e^{2i\pi\theta}$ die Zahl $2^n\theta$ zurück, wobei $n$ die Anzahl Qubits des Zählerregisters ist, die für bessere Präzision erhöht werden kann. 
\paragraph{}
\noindent Um zu verstehen, wie dieser Algorithmus funktioniert, erinnern wir uns zuerst daran, wie eine Zahl in der Fourierbasis aussieht. Dafür benutzen wir die Bloch-Kugel. Wir erinnern uns, dass für die Zahl $x$ in der Fourierbasis mit $n$ Qubits das $k$-te Qubit (hier muss man wieder aufpassen, denn wenn man die Faktorisierung anschaut, ist das $k$-te Qubit das $k$-te Qubit von rechts) um $\frac{2^kx}{2^n}$ um die Z-Achse gedreht wird. Das heisst, es befindet sich im Zustand $\frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi\frac{2^kx}{2^n}}\ket{1})$. Wir machen jetzt die Beobachtung, dass wir mit Hilfe von Phase-Kickback das gesuchte $\theta$ in der Fourierbasis in die Kontrollqubits schreiben können, da der Phase-Kickback nichts anderes macht, als das Kontrollqubit auf die selbe Art und Weise zu rotieren. Schauen wir uns einmal an, was passert, wenn wir $2^k$ mal kontrolliert den Operator $U$ anwenden (wobei hier $(U^c)^{2^k}$ für die kontrollierte Version von $U$ $2^k$ mal angewendet bedeutet):
\begin{align*}
\frac{1}{\sqrt{2}}(\ket{0} + \ket{1})\ket{\psi} \xrightarrow{(U^c)^{2^k}} \frac{1}{\sqrt{2}}(\ket{0\psi} + \ket{1}\otimes U^{2^k}\ket{\psi}) \\ = \frac{1}{\sqrt{2}}(\ket{0} + (e^{2i\pi\theta})^{2^k}\ket{1})\ket{\psi} \\
= \frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi2^k\theta}\ket{1})\ket{\psi} \\
= \frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi\frac{2^k(2^n\theta)}{2^n}}\ket{1})\ket{\psi}
\end{align*}
Dies entspricht genau dem $k$-ten Qubit der Repräsentation von $2^n\theta$ in der Fourierbasis. Das heisst, wenn wir also ein Zählerregister im Zustand $\ket{0}$ nehmen und dann für $k = 0, ..., n - 1$ zuerst das $H$-Gatter auf das $k$-te Qubit und dann $2^k$ mal ein kontrolliertes $U$ mit dem $k$-ten Qubit als Kontrollqubit auf den Eigenwert anwenden, erhalten wir das $k$-te Qubit der Darstellung von $2^n\theta$ in der Fourierbasis. Wenden wir anschliessend die inverse Fouriertransformation an, können wir die Zahl $2^n\theta$ im Zählerregister ablesen. Falls $2^n\theta$ keine ganze Zahl ist, erhalten wir im Zählerregister eine Superposition, wobei eine Zahl wahrscheinlicher ist, je näher sie beim echten Eigenwert liegt.

\paragraph{}

Um die Phase abzuschätzen, müssen wir also den Operator $U$ mehrmals hintereinander anwenden, zuerst nur einmal, dann zweimal, im $i$-ten Mal $2^i$ mal. Dies führt dazu, dass wir die Operation $2^n$ mal anwenden müssen. Allerdings ist es oft möglich, dass wir die Operation $U^{2^m}$ für einen beliebigen Parameter $m$ implementieren können. Wenn dies möglich ist, brauchen wir nur $n$ Anwendungen jener Operation.

\paragraph{Algorithmus}
\begin{enumerate}
    \item Initialisiere zwei Quantenregister, das Zählerregister und das Eigenvektor-Register, und setze das Eigenvektor-Register auf den gewünschten Eigenvektor $\ket{\psi}$.
    \item Wende $H^{\otimes n}$ auf das Zähler-Register an, um es auf $\ket{+}^{\otimes n}$ zu setzen.
    \item Für $k = 0, \dots, n - 1$: Wende auf den Eigenvektor $\ket{\varphi}$ die Operation $(U^{c_k})^{2^k}$, also die zur $2^k$-fachen Anwendung von $U$ äquivalente Operation kontrolliert durch das Qubit $c_k$, an.
    \item Wende die inverse Quantenfouriertransformation auf das Zählerregister an, um die Approximation in die binäre Basis umzurechnen.
    \item Miss das Zählerregister, um die Abschätzung abzulesen.
\end{enumerate}
\paragraph{}
\input{./assets/circuits/4.3.1.crct}
\captionof{figure}{Schaltkreis der Phasenabschätzung}
\paragraph{}

\section{Period Finding}
Gegeben sei eine Funktion $f : S \rightarrow S$ über eine endlichen Menge $S \subset \mathbb{Z}$, welche sich auf einem Quantencomputer implementieren lässt, und ein Wert $x \in S$. Wir versuchen nun, die kleinste Zahl $r \in \mathbb{N}$ zu berechnen, sodass $f^r(x) = x$ gilt.
\paragraph{}
Da die auf Quantencomputern berechneten Operationen unitär sind, müssen die Funktionswerte von $f$ mit invertierbaren Operation berechnet werden. Deshalb muss $f$ injektiv sein. Aus diesem Grund müssen $|S|$ verschiedene Funktionswerte von $f$ existieren, woraus die Surjektivität folgt. Somit ist $f$ bijektiv und man kann $f$ als Permutation der Elemente von $S$ interpretieren. Diese Permutation kann man als Komposition disjunkter Zykeln darstellen\footnote{Für eine genauere Beschreibung und einen Beweis verweise ich auf Seiten 23 ff. von \cite{perm}}.
Seien nun $\sigma_0, ..., \sigma_{k - 1}$ diese verschiedenen Zykeln. Dazu sei $S_i$ die Menge der Zahlen $j \in S$, so dass $\sigma_i(j) \neq j$ gilt.
\paragraph{}
Sei nun $x \in S_i$. Da $\sigma_i$ einen Zykel bildet, gilt $f^{|S_i|}(x) = x$. Gleichzeitig kann kein $r \in \mathbb{N}$ mit $r < |S_i|$ existieren, sodass $f^r(x) = x$ gilt, denn sonst hätte unser Zykel nur $r < |S_i|$ Elemente. Wir wollen nun also für ein $x \in S_i$ die Grösse $|S_i|$ finden.

\paragraph{}
\begin{wrapfigure}{l}{0.5\textwidth}
\input{./assets/graphs/4.4.1.grph}
\caption{\small Der Funktionsgraph der Funktion $g(x) = -x^3 + 1 \pmod{11}$}
\end{wrapfigure}

Als Beispiel nehmen wir $g : S \rightarrow S$ mit $S = \mathbb{Z}/11\mathbb{Z}$, $g(x) = -x^3 + 1$. Betrachten wir uns die Funktionswerte von $g$ an, sehen wir, dass diese Funktion bijektiv ist. Wenn wir den Graphen anschauen, sehen wir die einzelnen Zykeln und deren dazugehörige Mengen $S_i$: $S_0 = \{0, 1\}$, $S_1 = \{2, 3, 4, 7, 10\}$, $S_2 = \{5, 6, 8\}$ und $S_3 = \{9\}$. Wir sehen nun, dass $g^1(9) = 9$, $g^3(8) = 8$, $g^5(2) = 2$ etc. 

\paragraph{}

Die Frage ist nun, wie wir effizient die Grösse der Teilmenge finden können, in der $x$ sich befindet. Sei dafür $U_f$ der Operator, welcher $f$ auf Quantencomputern implementiert (welcher nach Voraussetzung existiert). Was passiert, wenn wir diesem Operator eine Superposition der Zahlen in $S_i$ übergeben? Seien $r = |S_i|$, $x_0, x_1, ..., x_{r - 1}$ die Zahlen in $S_i$, sodass $f(x_j) = x_{(j + 1) \pmod{r}}$ und $U_f$ die Quantenoperation, die $f$ implementiert. Schauen wir mal, was passiert, wenn wir $U_f$ auf den Zustand $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j}$ anwenden. Wir bekommen:
\begin{align*}
    U_f(\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j}) = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{f(x_j)} = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_{(j + 1) \pmod{r}}} = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j})
\end{align*}
Daraus schliessen wir, dass $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j}$ ein Eigenvektor von $U_f$ mit Eigenwert $1$ ist. Dieser Eigenwert ist nicht wirklich interessant. Wir können ihn aber interessanter machen, indem wir den einzelnen Summanden eine Phase mitgeben. Dazu konstruieren wir die Superposition $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})$ für ein $k < r$. Was passiert, wenn wie $U_f$ darauf anwenden? 
\begin{align*}
    U_f(\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})) = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_{(j + 1) \pmod{r}}}) = \\
    \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{k(j - 1)}{r}}\ket{x_j}) = e^{2i\pi\frac{k}{r}}(\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j}))
\end{align*}
Hier haben wir es mit einem Eigenvektor zum Eigenwert $e^{2i\pi\frac{k}{r}}$ zu tun. Dieser ist für uns interessant, weil $r$ darin vorkommt. Wir machen auch die Beobachtung, dass unser Eigenvektor von vorher ($\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j}$) auch von der Form ist, die wir gerade analysiert haben, einfach mit $k = 0$. Falls wir jetzt irgendwie einen Zustand von der Form $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})$ erzeugen können, könnten wir mit Hilfe der Phasenabschätzung den Quotienten $\frac{k}{r}$ abschätzen. Die Frage ist, wie können wir solch einen Zustand generieren? Zuerst sagen wir, $\ket{\psi_k}$ sei $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})$. Was passiert nun, wenn wir die Vektoren $\ket{\psi_0}, \ket{\psi_1}, ..., \ket{\psi_{r - 1}}$ aufsummieren?
\begin{align*}
    \frac{1}{\sqrt{r}}\sum_{k = 0}^{r - 1}\frac{1}{\sqrt{r}}(\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})) = \frac{1}{r}\sum_{j = 0}^{r - 1}\sum_{k = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j}) = \ket{x_0}
\end{align*}
Dieses überraschende Resultat lässt sich durch Expandieren beweisen. Aber eine einfachere Art zu sehen, dass dieses überraschende Resultat stimmt, ist, dass man die Summe $\sum_{k = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})$ für $j = 0$ betrachtet. Da $j = 0$ gilt, gilt $e^{-2i\pi\frac{kj}{r}} = e^{0} = 1$ und somit $\sum_{k = 0}^{r - 1}(e^{-2i\pi\frac{k\cdot 0}{r}}\ket{x_0}) = r\ket{x_0}$. Da $\frac{1}{r}(r\ket{x_j})$ bereits einen Betrag von $1$ hat, kann kein anderer Zustand mit positivem Betrag existieren, da die Beträge sich sonst zu etwas Grösserem als $1$ aufsummieren würden.

\paragraph{}

Sei nun $\ket{\psi_k} = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})$ eine kürzere Schreibweise für die oben genannten Eigenvektoren. Somit ist $\ket{x_0}$ einfach eine Superposition der Eigenvektoren $\ket{\psi_0}, ..., \ket{\psi_{r - 1}}$. Das heisst, wenn wir der Periodenabschätzungsfunktion einen Wert mitgeben, den wir als $\ket{x_0}$ gebrauchen können, haben wir eine Superposition dieser Eigenvektoren. Probieren wir nun, den Eigenwert dieser Superposition abzuschätzen.

\paragraph{}
Betrachten wir den Phasenabschätzungs-Algorithmus nochmals bis zum Punkt bevor wir das Register messen. Dies alles können wir als eine Operation $P$ mit $P\ket{0}\ket{\psi} \rightarrow \ket{2^m\theta}\ket{\psi}$ zu einem Eigenvektor $\ket{\psi}$ schreiben, wobei $m$ die gewählte Genauigkeit der Phasenabschätzung ist. Da die auf Quantencomputern implementierten Operationen linear sind, gilt: $$P\ket{0}\ket{x_0} = P\left(\ket{0}\left(\sum_{k = 0}^{r - 1}\ket{\psi_k}\right)\right) = \sum_{k = 0}^{r - 1}\left(P\ket{0}\ket{\psi_k}\right) = \sum_{k = 0}^{r - 1}\left(\ket{2^m\theta_k}\ket{\psi_k}\right) = \sum_{k = 0}^{r - 1}\left(\ket{2^m\frac{k}{r}}\ket{\psi_k}\right)$$

Messen wir somit dann das Resultat, so kollabiert diese Superposition und wir bekommen den Wert $2^n\frac{k}{r}$ für ein $k \in \{0, \dots r - 1\}$, wobei alle die gleiche Wahrscheinlichkeit haben. Mit Hilfe der von Kettenbrüchen\footnote{Auf eine geneauere Betrachtung von Kettenbrüchen verzichte ich hier, sollte der Leser damit nicht vertraut sein, verweise ich auf \cite{Frac}} können wir nun den Bruch $\frac{k}{r}$ vom Bruch $\frac{2^m\frac{r}{k}}{2^m}$ abschätzen. Nun stellt sich heraus, wenn $m \geq 2n$ gilt, dann ist der Bruch $\frac{2^m\frac{k}{r}}{2^m}$ genug genau, dass der nächste Bruch mit Nenner kleiner oder gleich $n$ an $\frac{2^m\frac{k}{r}}{2^m}$ der Bruch $\frac{k}{r}$ selbst ist\footnote{Für dieses Resultat verweise ich auf \cite{QC}. Die Beschreibung befindet sich auf Seite 229 und der Beweis des dazu gebrauchten Theorems im Appendix 4}. Wenn wir also mit Hilfe von Kettenbrüchen den Näherungsbruch mit dem grössten Nenner kleiner oder gleich $n$ nehmen, dass dieser Näherungsbruch $\frac{k}{r}$ sein muss.
\paragraph{}
Nun kann es sein, dass $ggT(k, r) = g \neq 1$ gilt, somit der Bruch mit $g$ gekürzt wird, und wir so an Stelle von $r$ die Zahl $\frac{r}{g}$ zurückbekommen. Wir können aber durch Anwendung von $f^r$ überprüfen, ob $r$ tatsächlich die Periode ist, da für $r' < r$ die Gleichung $f^{r'}(x) = x$ nicht gelten kann. Und um den richtigen Wert $r$ zu bekommen, können wir die Prozedur wiederholen. Wiederholen wir sie $2\log(N)$ mal, bekommen wir mit sehr hoher Wahrscheinlichkeit mindestens einmal die korrekte Periode. Den Beweis dazu kann man in \cite{QC}, Seiten 229ff., nachlesen.

\section{Die Ordnung von Zahlen bestimmen}
Der Algorithmus von Shor ist deshalb so schnell, da mit Hilfe des quantenbasierten Teils des Algorithmus die Ordnung einer Zahl effizient bestimmt werden kann. Die Ordnung einer Zahl $a$ Modulo einer Zahl $n$, geschrieben als $ord_n(a)$, ist die kleinste positive Zahl $r$, sodass $a^r \equiv 1 \pmod{n}$ gilt. Dabei muss $gcd(a, n) = 1$ gelten, denn sonst kann dieses $r$ nicht existieren. Wir rechnen nun in $\mathbb{Z} / n \mathbb{Z}$. Da $ord_n(a)$ nichts anderes ist als die Periode der Funktion $g(x) = a^x$, können wir die Funktion $f(x) = ax$ implementieren, sodass $f_s(x) = f^x(s) = sa^x$ gilt. Mit $s = 1$ bekommen wir dann $f_1(x) = f^x(1) = a^x$. Sei $U$ die Quantenoperation, die $f_1$ implementiert, dafür können wir einfach die Multiplikation aus der QInteger-Library verwenden. Gleichzeitig können wir auch $U^{2^i}$ effizient implementieren: $U^{2^i}$ ist nichts anderes als die Operation zu $f^{2^i}$. Da $f^{2^i}(x) = a^{2^i}x$, können wir ganz einfach $a^{2^i}$ klassisch berechnen und dann wieder die gewöhnliche Multiplikation aus der QInteger-Library verwenden. Wir können nun den Algorithmus aus dem vorherigen Kapitel verwenden, um die Periode der Funktion $f_1(x) = a^x$ abzuschätzen. Wir brauchen dafür nur noch eine Funktion, die $f(x) = a^x$ klassisch berechnet, um das Resultat überprüfen zu können, dafür kann man direkt FastPowMod aus der QInteger-Library verwenden. Dies führt dazu, dass der Code dieser Funktion nur sehr kurz ist.

\section{Das Ziel - Der Shor-Algorithmus}
Wie erlaubt uns dies nun, Zahlen zu faktorisieren? Sei $n$ die zu faktorisierende Zahl. Zuerst überprüfen wir, ob die Zahl durch 2 teilbar oder eine Primpotenz ist, und finden diese Faktoren entsprechend. Nun nehmen wir ein zufälliges $1 < a < n$. Falls $g = ggT(a, n) \neq 1$, haben wir bereits einen Teiler gefunden, nämlich $g$. Sonst sind $a$ und $n$ teilerfremd. Danach suchen wir die Ordnung von $a$ modulo $n$. Falls diese Ordnung ungerade ist, beginnen wir nochmals von vorne, sonst ist sie gerade. Sei diese Ordnung $r$. Mit $r$ können wir nun mit gewisser Wahrscheinlichkeit einen Teiler finden. Falls $a^{\frac{r}{2}} \not\equiv -1 \pmod n$ gilt, haben wir eine Wurzel von $1 \pmod{n}$ gefunden, sonst müssen wir es noch einmal versuchen. Da $r$ die Ordnung von $a$ ist, muss $a^{\frac{r}{2}}\not\equiv 1 \pmod{n}$ gelten. Nun gilt: $n | (a^\frac{r}{2} + 1)(a^\frac{r}{2} - 1)$, aber $n \not| \; a^\frac{r}{2} + 1$ und $n \not| \; a^\frac{r}{2} - 1$. Wir haben zwei Zahlen $b$ und $c$, sodass $n | bc$, aber $n \not | \; b$ und $n \not | \; c$. Sei $n = p_0^{\alpha_0}p_1^{\alpha_1}...$. Schreibe $b = s_bp_0^{\beta_0}p_1^{\beta_1}...$ und $b = s_cp_0^{\gamma_0}p_1^{\gamma_1}...$. Wir wissen nun, dass $\beta_i + \gamma_i \geq \alpha_i$ gelten muss, da sonst $n | bc$ nicht erfüllt wäre. Gleichzeitig müssen ein $j_b$ und ein $j_c$ existieren, sodass $\beta_{j_b} > 0$ und $\gamma_{j_c} > 0$ stimmt. Nehme an, dass ohne Beschränkung der Allgemeinheit $\gamma_i = 0$ für alle $i$ gelte. Dann müsste $\beta_i \geq \alpha_i$ für alle $i$ gelten und $n \; | \; b$ teilen, was ein Widerspruch zur Annahme $n \not | \; b$ wäre. Somit beinhalten beide Faktoren $b$ und $c$ Teiler von $n$, welche mit dem einfachen $ggT$-Algorithmus extrahiert werden können. Somit kennen wir nun den ganzen Algorithmus, um einen Teiler von $n$ zu finden.
\begin{enumerate}
    \item Falls $n$ durch zwei teilbar ist, gib 2 zurück und terminiere.
    \item Falls $n = p^a$ eine Primpotenz ist, gib die Primzahl $p$ zurück und terminiere.
    \item Bestimme eine zufällige Zahl $1 < a < n - 1$.
    \item Finde $g = ggT(a, n)$. Falls $g \neq 1$ ist, gib $g$ zurück und terminiere.
    \item Bestimme die Ordnung von $a$ modulo $n$ mit Hilfe des Quantenteils des Algorithmus:
    \begin{enumerate}
        \item Schätze die Phase des Operators $U_f$ ab, der $f(x) = ax$ implementiert mit einer Präzision von $m = 2\log_2(n)$ ab. Benutze dazu den in Kapitel 4.3 vorgestellten Algorithmus. Sei das Resultat $2^m\lambda$.
        \item Schätze den Quotienten $\frac{k}{r}$ von $\frac{2^m\lambda}{2^m}$ ab. Falls $r$ nicht die gesuchte Periode ist, gehe zurück zu (a), sonst gib die Periode $r$ zurück.
    \end{enumerate}
    \item Falls $r$ ungerade ist, gehe zurück zu 2. Sonst berechne $a^{r / 2} \pmod{n}$. Falls dies kongruent zu $-1 \pmod{n}$ ist, gehe zurück zu 2.
    \item Berechne $b = (a^\frac{r}{2} + 1)$. Gib $ggT(b, n)$ zurück und terminiere.
\end{enumerate}