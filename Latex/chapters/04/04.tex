\chapter{Der Weg zum Shor-Algorithmus}
\section{Überblick}
Im folgenden Kapitel werden wir uns die relevanten Konzepte und Ideen hinter dem quantenbasierten Teil des Shor-Algorithmus anschauen. Dabei beginnen wir beim simplen Konzept des \grqq Phase Kickback\grqq{} , schauen uns dann die darauf basierende Phasenabschätzung an, bevor wir mit deren Hilfe die Ordnung einer Zahl finden. Zum Schluss werden wir uns den kompletten quantenbasierten Teil des Algorithmus zusammenfassend anschauen.
\section{Phase Kickback}
Beginnen wir den Abschnitt mit einer Frage: Wenn wir eine kontrollierte Operation ausführen, sollte sich das Control-Qubit eigentlich nicht ändern, oder? In diesem Abschnitt werden wir sehen, dass dies überraschenderweise doch so sein kann. Dafür schauen wir uns das CNOT-Gatter an. Was geschieht, wenn wir CNOT auf zwei Qubits im Zustand $\ket{+-}$ anwenden\footnote{$\ket{+}$ und $\ket{-}$ sind im Kapitel 2.2.4 definiert.}, mit dem ersten Qubit als Control-Qubit? Zuerst haben wir $\ket{+-} = \frac{1}{2}(\ket{00} - \ket{01} + \ket{10} - \ket{11})$. Nachdem wir das CNOT anwenden, bekommen wir den Zustand $\frac{1}{2}(\ket{00} - \ket{01} - \ket{10} + \ket{11}) = \ket{--}$. Überraschenderweise stellen wir fest, dass sich das Control-Qubit verändert hat, während das Ziel-Qubit gleich blieb. Was ist passiert? Betrachten wir das CNOT-Gatter genauer: Das CNOT-Gatter ist nichts anderes als eine kontrollierte Version des $X$-Gatters. Was geschieht, wenn wir das $X$-Gatter auf den $\ket{-}$-Zustand anwenden? $X\ket{-} = -\ket{0} + \ket{1} = -\ket{-} = (-1)*\ket{-}$. Hier können wir sehen, dass $\ket{-}$ ein Eigenvektor des $X$-Gatters mit Eigenwert $-1$ ist. Der Zustand ändert sich somit bis auf einen globalen Faktor nicht, den wir - wie in 2.2.2 erklärt wurde - nicht durch eine Messung unterscheiden können.

\paragraph{}

Wenn wir hingegen die Operation kontrolliert durchführen, wird diese Phase nur in den Zuständen sichtbar, in welchen die Operation durchgeführt wurde, sprich in den Zuständen, in denen das Control-Qubit im Zustand $\ket{1}$ ist. Dies konnten wir zuvor beim CNOT-Gatter beobachten. Betrachten wir nun eine allgemeinere Operation $U$ mit einem Eigenvektor $\ket{\psi}$ und dem Eigenwert $\lambda$. Nehmen wir jetzt ein Kontrollqubit im Zustand $\alpha\ket{0} + \beta\ket{1}$, ein Qubit-Register im Zustand $\ket{\psi}$ und wenden $U$ auf das Register $\ket{\psi}$ an, kontrolliert durch jenes Kontrollqubit:
\begin{align*}
(\alpha\ket{0} + \beta\ket{1})\ket{\psi} \xrightarrow{U^c} \alpha\ket{0\psi} + \beta\ket{1}*U\ket{\psi} = (\alpha\ket{0} + \lambda\beta\ket{1})\ket{\psi}
\end{align*}
Das Ziel-Qubit verändert sich nicht, es ist ja ein Eigenvektor, stattdessen sehen wir, dass der Eigenwert zurück in die Phase des Kontrollqubit \grqq gekickt\grqq{} wird, daher der Name \grqq Phase Kickback\grqq{}. Im nächsten Abschnitt werden wir diesen Effekt anwenden, um den Eigenwert eines Operators abzschätzen.

\section{Phasenabschätzung}
Verschiedene Quanten-Algorithmen basieren darauf, den Eigenwert eines Operators zu einem Eigenvektor abzuschätzen. Dazu benutzen wir Phase-Kickbacks, um den Eigenwert in ein Zähler-register in der Fourier-Basis zu schreiben, welches wir dann mit der inversen Quantenfourier-transformation in die binäre Basis zurückrechnen. Dazu können wir die Anzahl Qubits variieren, um die Präzision der Approximation festlegen. Genauer gibt der Algorithmus zum Eigenwert $\lambda = e^{2i\pi\theta}$ die Zahl $2^n\theta$ zurück, wobei $n$ die Anzahl Qubits des Zählerregisters ist, die für bessere Präzision erhöht werden kann. 
\paragraph{}
\noindent Um zu verstehen, wie dieser Algorithmus funktioniert, erinnern wir uns zuerst daran, wie eine Zahl in der Fourierbasis aussieht. Dafür benutzen wir die Bloch-Kugel. Wir erinnern uns, dass für die Zahl $x$ in der Fourierbasis mit $n$ Qubits das $k$-te Qubit (hier muss man wieder aufpassen, denn wenn man die Faktorisierung anschaut, ist das $k$-te Qubit das $k$-te Qubit von rechts) um $\frac{2^kx}{2^n}$ um die Z-Achse gedreht wird. Das heisst, es befindet sich im Zustand $\frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi\frac{2^kx}{2^n}}\ket{1})$. Wir machen jetzt die Beobachtung, dass wir mit Hilfe von Phase-Kickback das gesuchte $\theta$ in der Fourierbasis in die Kontrollqubits schreiben können, da der Phase-Kickback nichts anderes macht, als das Kontrollqubit auf die selbe Art und Weise zu rotieren. Schauen wir uns einmal an, was passert, wenn wir $2^k$ mal kontrolliert den Operator $U$ anwenden (wobei hier $(U^c)^{2^k}$ für die kontrollierte Version von $U$ $2^k$ mal angewendet bedeutet):
\begin{align*}
\frac{1}{\sqrt{2}}(\ket{0} + \ket{1})\ket{\psi} \xrightarrow{(U^c)^{2^k}} \frac{1}{\sqrt{2}}(\ket{0\psi} + \ket{1}\otimes U^{2^k}\ket{\psi}) \\ = \frac{1}{\sqrt{2}}(\ket{0} + (e^{2i\pi\theta})^{2^k}\ket{1})\ket{\psi} \\
= \frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi2^k\theta}\ket{1})\ket{\psi} \\
= \frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi\frac{2^k(2^n\theta)}{2^n}}\ket{1})\ket{\psi}
\end{align*}
Dies entspricht genau dem $k$-ten Qubit der Repräsentation von $2^n\theta$ in der Fourierbasis. Das heisst, wenn wir also ein Zählerregister im Zustand $\ket{0}$ nehmen und dann für $k = 0, ..., n - 1$ zuerst das $H$-Gatter auf das $k$-te Qubit und dann $2^k$ mal ein kontrolliertes $U$ mit dem $k$-ten Qubit als Kontrollqubit auf den Eigenwert anwenden, erhalten wir das $k$-te Qubit der Darstellung von $2^n\theta$ in der Fourierbasis. Wenden wir anschliessend die inverse Fouriertransformation an, können wir die Zahl $2^n\theta$ im Zählerregister ablesen. Falls $2^n\theta$ keine ganze Zahl ist, erhalten wir im Zählerregister eine Superposition, wobei eine Zahl wahrscheinlicher ist, je näher sie beim echten Eigenwert liegt.

\paragraph{}

Um die Phase abzuschätzen, müssen wir also den Operator $U$ mehrmals hintereinander anwenden, zuerst nur einmal, dann zweimal, im $i$-ten Mal $2^i$ mal. Dies führt dazu, dass wir die Operation $2^n$ mal anwenden müssen. Allerdings ist es oft möglich, dass wir die Operation $U^{2^m}$ für einen beliebigen Parameter $m$ implementieren können. Wenn dies möglich ist, brauchen wir nur $n$ Anwendungen jener Operation.

\paragraph{Algorithmus}
\begin{enumerate}
    \item Initialisiere zwei Quantenregister, das Zählerregister und das Eigenvektor-Register, und setze das Eigenvektor-Register auf den gewünschten Eigenvektor $\ket{\psi}$.
    \item Wende $H^{\otimes n}$ auf das Zähler-Register an, um es auf $\ket{+}^{\otimes n}$ zu setzen.
    \item Für $k = 0, \dots, n - 1$: Wende auf den Eigenvektor $\ket{\varphi}$ die Operation $(U^{c_k})^{2^k}$, also die zur $2^k$-fachen Anwendung von $U$ äquivalente Operation kontrolliert durch das Qubit $c_k$, an.
    \item Wende die inverse Quantenfouriertransformation auf das Zählerregister an, um die Approximation in die binäre Basis umzurechnen.
    \item Miss das Zählerregister, um die Abschätzung abzulesen.
\end{enumerate}
\paragraph{}
\input{./assets/circuits/4.3.1.crct}
\captionof{figure}{Schaltkreis der Phasenabschätzung}
\paragraph{}

\section{Periodenabschätzung}
Gegeben sei eine Funktion $f : S \rightarrow S$ über eine endlichen Menge $S \subset \mathbb{Z}$, welche sich auf einem Quantencomputer implementieren lässt, und ein Wert $x \in S$. Wir versuchen nun, die kleinste Zahl $r \in \mathbb{N}$ zu berechnen, sodass $f^r(x) = x$ gilt.
\paragraph{}
Da die auf Quantencomputern berechneten Operationen unitär sind, müssen die Funktionswerte von $f$ mit invertierbaren Operation berechnet werden. Deshalb muss $f$ injektiv sein. Aus diesem Grund müssen $|S|$ verschiedene Funktionswerte von $f$ existieren, woraus die Surjektivität folgt. Somit ist $f$ bijektiv und man kann $f$ als Permutation der Elemente von $S$ interpretieren. Diese Permutation kann man als Komposition disjunkter Zykeln darstellen\footnote{Für eine genauere Beschreibung und einen Beweis verweise ich auf Seiten 23 ff. von \cite{perm}}.
Seien nun $\sigma_0, ..., \sigma_{k - 1}$ diese verschiedenen Zykeln. Dazu sei $S_i$ die Menge der Zahlen $j \in S$, so dass $\sigma_i(j) \neq j$ gilt.
\paragraph{}
Sei nun $x \in S_i$. Da $\sigma_i$ einen Zykel bildet, gilt $f^{|S_i|}(x) = x$. Gleichzeitig kann kein $r \in \mathbb{N}$ mit $r < |S_i|$ existieren, sodass $f^r(x) = x$ gilt, denn sonst hätte unser Zykel nur $r < |S_i|$ Elemente. Wir wollen nun also für ein $x \in S_i$ die Grösse $|S_i|$ finden.

\paragraph{}
\begin{wrapfigure}{l}{0.5\textwidth}
\input{./assets/graphs/4.4.1.grph}
\caption{\small Der Funktionsgraph der Funktion $g(x) = -x^3 + 1 \pmod{11}$}
\end{wrapfigure}

Als Beispiel nehmen wir $g : S \rightarrow S$ mit $S = \mathbb{Z}/11\mathbb{Z}$, $g(x) = -x^3 + 1$. Betrachten wir uns die Funktionswerte von $g$ an, sehen wir, dass diese Funktion bijektiv ist. Wenn wir den Graphen anschauen, sehen wir die einzelnen Zykeln und deren dazugehörige Mengen $S_i$: $S_0 = \{0, 1\}$, $S_1 = \{2, 3, 4, 7, 10\}$, $S_2 = \{5, 6, 8\}$ und $S_3 = \{9\}$. Wir sehen nun, dass $g^1(9) = 9$, $g^3(8) = 8$, $g^5(2) = 2$ etc. 

\paragraph{}

Die Frage ist nun, wie wir effizient die Grösse der Teilmenge finden können, in der $x$ sich befindet. Sei dafür $U_f$ der Operator, welcher $f$ auf Quantencomputern implementiert (welcher nach Voraussetzung existiert). Was passiert, wenn wir diesem Operator eine Superposition der Zahlen in $S_i$ übergeben? Seien $r = |S_i|$, $x_0, x_1, ..., x_{r - 1}$ die Zahlen in $S_i$, sodass $f(x_j) = x_{(j + 1) \pmod{r}}$ und $U_f$ die Quantenoperation, die $f$ implementiert. Schauen wir mal, was passiert, wenn wir $U_f$ auf den Zustand $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j}$ anwenden. Wir bekommen:
\begin{align*}
    U_f(\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j}) = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{f(x_j)} = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_{(j + 1) \pmod{r}}} = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j})
\end{align*}
Daraus schliessen wir, dass $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j}$ ein Eigenvektor von $U_f$ mit Eigenwert $1$ ist. Dieser Eigenwert ist nicht wirklich interessant. Wir können ihn aber interessanter machen, indem wir den einzelnen Summanden eine Phase mitgeben. Dazu konstruieren wir die Superposition $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})$ für ein $k < r$. Was passiert, wenn wie $U_f$ darauf anwenden? 
\begin{align*}
    U_f(\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})) = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_{(j + 1) \pmod{r}}}) = \\
    \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{k(j - 1)}{r}}\ket{x_j}) = e^{2i\pi\frac{k}{r}}(\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j}))
\end{align*}
Hier haben wir es mit einem Eigenvektor zum Eigenwert $e^{2i\pi\frac{k}{r}}$ zu tun. Dieser ist für uns interessant, weil $r$ darin vorkommt. Wir machen auch die Beobachtung, dass unser Eigenvektor von vorher ($\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j}$) auch von der Form ist, die wir gerade analysiert haben, einfach mit $k = 0$. Falls wir jetzt irgendwie einen Zustand von der Form $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})$ erzeugen können, könnten wir mit Hilfe der Phasenabschätzung den Quotienten $\frac{k}{r}$ abschätzen. Die Frage ist, wie können wir solch einen Zustand generieren? Zuerst sagen wir, $\ket{\psi_k}$ sei $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})$. Was passiert nun, wenn wir die Vektoren $\ket{\psi_0}, \ket{\psi_1}, ..., \ket{\psi_{r - 1}}$ aufsummieren?
\begin{align*}
    \frac{1}{\sqrt{r}}\sum_{k = 0}^{r - 1}\frac{1}{\sqrt{r}}(\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})) = \frac{1}{r}\sum_{j = 0}^{r - 1}\sum_{k = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j}) = \ket{x_0}
\end{align*}
Dieses überraschende Resultat lässt sich durch Expandieren beweisen. Aber eine einfachere Art zu sehen, dass dieses überraschende Resultat stimmt, ist, dass man die Summe $\sum_{k = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})$ für $j = 0$ betrachtet. Da $j = 0$ gilt, gilt $e^{-2i\pi\frac{kj}{r}} = e^{0} = 1$ und somit $\sum_{k = 0}^{r - 1}(e^{-2i\pi\frac{k\cdot 0}{r}}\ket{x_0}) = r\ket{x_0}$. Da $\frac{1}{r}(r\ket{x_j})$ bereits einen Betrag von $1$ hat, kann kein anderer Zustand mit positivem Betrag existieren, da die Beträge sich sonst zu etwas Grösserem als $1$ aufsummieren würden.

\paragraph{}

Sei nun $\ket{\psi_k} = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})$ eine kürzere Schreibweise für die oben genannten Eigenvektoren. Somit ist $\ket{x_0}$ einfach eine Superposition der Eigenvektoren $\ket{\psi_0}, ..., \ket{\psi_{r - 1}}$. Das heisst, wenn wir der Periodenabschätzungsfunktion einen Wert mitgeben, den wir als $\ket{x_0}$ gebrauchen können, haben wir eine Superposition dieser Eigenvektoren. Probieren wir nun, den Eigenwert dieser Superposition abzuschätzen.

\paragraph{}
Betrachten wir den Phasenabschätzungs-Algorithmus nochmals bis zum Punkt bevor wir das Register messen. Dies alles können wir als eine Operation $P$ mit $P\ket{0}\ket{\psi} \rightarrow \ket{2^m\theta}\ket{\psi}$ zu einem Eigenvektor $\ket{\psi}$ schreiben, wobei $m$ die gewählte Genauigkeit der Phasenabschätzung ist. Da die auf Quantencomputern implementierten Operationen linear sind, gilt: $$P\ket{0}\ket{x_0} = P\left(\ket{0}\left(\sum_{k = 0}^{r - 1}\ket{\psi_k}\right)\right) = \sum_{k = 0}^{r - 1}\left(P\ket{0}\ket{\psi_k}\right) = \sum_{k = 0}^{r - 1}\left(\ket{2^m\theta_k}\ket{\psi_k}\right) = \sum_{k = 0}^{r - 1}\left(\ket{2^m\frac{k}{r}}\ket{\psi_k}\right)$$

Messen wir somit dann das Resultat, so kollabiert diese Superposition und wir bekommen den Wert $2^m\frac{k}{r}$ für ein $k \in \{0, \dots r - 1\}$, wobei alle die gleiche Wahrscheinlichkeit haben. Mit Hilfe der von Kettenbrüchen\footnote{Auf eine geneauere Betrachtung von Kettenbrüchen verzichte ich hier, sollte der Leser damit nicht vertraut sein, verweise ich auf \cite{Frac}} können wir nun den Bruch $\frac{k}{r}$ vom Bruch $\frac{2^m\frac{r}{k}}{2^m}$ abschätzen. Nun stellt sich heraus, wenn $m \geq 2n$ gilt, dann ist der Bruch $\frac{2^m\frac{k}{r}}{2^m}$ genug genau, dass der nächste Bruch mit Nenner kleiner oder gleich $n$ an $\frac{2^m\frac{k}{r}}{2^m}$ der Bruch $\frac{k}{r}$ selbst ist\footnote{Für dieses Resultat verweise ich auf \cite{QC}. Die Beschreibung befindet sich auf Seite 229 und der Beweis des dazu gebrauchten Theorems im Appendix 4}. Wenn wir also mit Hilfe von Kettenbrüchen den Näherungsbruch mit dem grössten Nenner kleiner oder gleich $n$ nehmen, dass dieser Näherungsbruch $\frac{k}{r}$ sein muss.
\paragraph{}
Nun kann es sein, dass $\text{ggT}(k, r) = g \neq 1$ gilt, somit der Bruch mit $g$ gekürzt wird, und wir so an Stelle von $r$ die Zahl $\frac{r}{g}$ zurückbekommen. Wir können aber durch Anwendung von $f^r$ überprüfen, ob $r$ tatsächlich die Periode ist, da für $r' < r$ die Gleichung $f^{r'}(x) = x$ nicht gelten kann. Und um den richtigen Wert $r$ zu bekommen, können wir die Prozedur wiederholen. Wiederholen wir sie $2\log(N)$ mal, bekommen wir mit sehr hoher Wahrscheinlichkeit mindestens einmal die korrekte Periode. Den Beweis dazu kann man in \cite{QC}, Seiten 229ff., nachlesen.

\section{Die Ordnung von Zahlen bestimmen}
Der Algorithmus von Shor ist deshalb so schnell, da mit Hilfe des quantenbasierten Teils des Algorithmus die Ordnung einer Zahl effizient bestimmt werden kann. Die Ordnung einer Zahl $a$ modulo einer Zahl $n$, geschrieben als $ord_n(a)$, ist die kleinste positive Zahl $r$, sodass $a^r \equiv 1 \pmod{n}$ gilt. Dabei muss $\text{ggT}(a, n) = 1$ gelten, denn sonst kann dieses $r$ nicht existieren (zum Beispiel gibt es kein $r$ mit $2^r \equiv 1 \pmod{8}$). Wenn diese Bedingung aber erfüllt ist, so sagt der Satz von Euler-Fermat, dass $a^{\phi(n)} \equiv 1 \pmod{n}$ gilt, wobei $\phi(n)$ die eulersche Phi-Funktion ist. 

\paragraph{}
Da $\text{ggT}(a, n) = 1$ gilt, ist die Restklasse kongruent zu $a$ modulo $n$ ein Element der primen Restklassengruppe $(\mathbb {Z}/n\mathbb {Z} )^{\times}$. Dies setzt sofort die Existenz eines inversen Elements $a^{-1}$ modulo $n$ voraus. Wir rechnen nun in $(\mathbb {Z}/n\mathbb {Z})^{\times}$.
\paragraph{}
Sei $f$ definiert als $f(x) := ax$. Da diese Funktion invertierbar ist (die inverse Funktion ist $f^{-1}(x) = a^{-1}x$), ist sie bijektiv. Wir stellen nun fest, dass die Zahl $r = ord_n(n)$ die kleinste Zahl ist, sodass $f^r(1) = a^r\cdot 1 = 1$ gilt. Da $f$ bijektiv ist, ist es wahrscheinlich, dass man sie auf Quantencomputern implementieren kann. Und tatsächlich haben wir diese Funktion implementiert: Sie ist nichts anderes als die in 3.5 beschriebene Modulare Multiplikation.

\paragraph{}
Seu $U_f$ die Quantenoperation, die $f$ auf Quantencomputern implementiert. Nun können wir der Periodenabschätzungsfunktion diesen Quantenoperator und als Startwert die Zahl $1$ übergeben, und sie berechnet für uns die kleinste Zahl $r$, so dass $f^r(1) = 1$ gilt, was tatsächlich die gesuchte Ordnung ist. Um klassisch effizient überprüfen zu können, ob das gefundene $r$ die wirkliche Ordnung ist, können wir die Binäre Exponentiation\footnote{Siehe auch \cite{clrs}, Kapitel 31} verwenden.
\paragraph{}
Nun stellt sich die Frage, ob sich $U_f^{2^k}$ effizient implementieren lässt. Dazu stellen wir fest, dass $U_f^{2^k}$ nichts anderes als die Quantenoperation ist, welche $f^{2^k}$ implementiert. Gleichzeitig gilt $f^{2^k}(x) = a^{2^k}x$. Dies wiederum ist nichts anderes als eine Modulare Multiplikation mit der Zahl $a^{2^k}$, wobei sich die Zahl $a^{2^k} \pmod{n}$ klassisch effizient berechnen lässt (auch dazu können wir wieder die Binäre Exponentiation verwenden). Somit können wir für jedes $k$ die Quantenoperation $U_f^{2^k}$ mit nur einer modularen Multiplikation implementieren.
\paragraph{}
Fassen wir all dies zusammen, können wir die im vorherigen Kapitel erklärte Periodenabschätzungsfunktion verwenden, um die Ordnung einer Zahl $a$ modulo einer Zahl $n$ effizient abzuschätzen, falls $\text{ggT}(a, n) = 1$ gilt.

\section{Das Ziel - Der Shor-Algorithmus}
\subsection{Der Algorithmus}
Im Grunde genommen erlaubt uns der Algorithmus von Shor nur, einen nicht-trivialen Teiler $d$ von $n$ zu finden. Dies lässt sich jedoch leicht zu einem Algorithmus, welcher Zahlen faktorisiert, umschreiben: Solange $n$ keine Primpotenz ist, finde einen nicht-trivialen Teiler $d$ von $n$ und faktorisiere rekursiv die beiden Zahlen $d$ und $\frac{n}{d}$. Probieren wir nun, einen nicht-trivialen Teiler von $n$ zu finden.

\paragraph{}
In einem ersten Schritt überprüfen wir, ob $n$ durch $2$ teilbar oder eine Primpotenz ist. Letzteres lässt sich überprüfen, indem man für jede möglich Potenz $s \leq \log(n)$ überprüft, ob eine Zahl $p$ mit $p^s = n$ existiert. Diese Zahl $p$, falls sie existiert, kann man mit einer binären Suche finden.
\paragraph{}
Als nächstes wählen wir eine zufällige Zahl $a$ mit $1 < a < n$. Falls $\text{ggT}(a, n) \neq 1$ gilt, hat man bereits einen nicht-trivialen Teiler gefunden, den man zurückgeben kann. Sonst bestimmen wir mit Hilfe der Periodenabschätzung wie im Kapitel 4.5 beschrieben die Ordnung der Zahl $a$ modulo $n$. Dies ist der einzige Schritt des Algorithmus, an dem wir Quantencomputer benötigen. Sei diese Ordnung $r$. Falls $r$ ungerade ist oder $a^\frac{r}{2} \equiv -1 \pmod{n}$ gilt, beginnen wir wieder von vorne. Die Wahtrscheinlichkeit, dass wir wieder von vorne beginnen müssen, ist dabei aber kleiner oder gleich $\frac{1}{2^m}$,  wobei $m$ die Anzahl verschiedener Primteiler von $n$ ist. Den Beweis dazu kann man in \cite{QC} Seiten 233ff. nachlesen.
\paragraph{}

Wir sind nun im Besitz einer Zahl $a$ mit Ordnung $r$, wobei $2 \mid r$ und $a^\frac{r}{2} \not\equiv -1 \pmod{n}$ gilt. Da $r$ die Ordnung ist, gilt auch $a^\frac{r}{2} \not\equiv 1 \pmod{n}$. Dies bedeutet, wir haben eine nicht-triviale Wurzel von $1$ modulo $n$ gefunden. Nun gilt $n \mid (a^\frac{r}{2} + 1)(a^\frac{r}{2} - 1)$, aber $n \not| \; a^\frac{r}{2} + 1$ und $n \not| \; a^\frac{r}{2} - 1$. Somit haben wir zwei Zahlen $b = a^\frac{r}{2} + 1$ und $c = a^\frac{r}{2} - 1$ mit:
\begin{align}
    n \mid bc \label{eq:1} \\
    n \not| \; b \label{eq:2} \\
    n \not| \; c \label{eq:3}
\end{align}    
Sei nun $p_0^{\alpha_0}p_1^{\alpha_1}... = n$ die Primzahlzerlegung von $n$, $p_0^{\beta_0}p_1^{\beta_1}... = b$ diejenige von $b$ und $p_0^{\gamma_0}p_1^{\gamma_1}... = c$ diejenige von $c$. Aus (1) wissen wir nun, dass für jedes $k$ die Ungleichung $\beta_k + \gamma_k \geq \alpha_k$ gelten muss. Gleichzeitig folgt aus (2) und (3), dass ein $i$ und ein $j$ existieren müssen, so dass $\beta_i < \alpha_i$ und $\gamma_j < \alpha_j$ gelten. Daraus folgt, dass $\text{ggT}(b, n)$ und $\text{ggT}(c, n)$ nicht $n$ sein können. Gleichzeitig müssen wegen $\beta_k + \gamma_k \geq \alpha_k$ auch $\gamma_i > 0$ und $\beta_j > 0$ gelten, woraus $\text{ggT}(b, n) > 1$ und $\text{ggT}(c, n) > 1$ folgt.
\paragraph{}
Daraus schliessen wir, dass beide Zahlen $b$ und $c$ Faktoren von $n$ enthalten. Diese können durch die Berechnung von $\text{ggT}(b, n)$ und $\text{ggT}(b, n)$ mit Hilfe des euklidischen Algorithmus extrahiert werden. Fassen wir all dies zusammen, sind wir nun im Besitz eines Algorithmus, der einen nicht-trivialen Teiler von $n$ findet:
\begin{enumerate}
    \item Falls $n$ durch zwei teilbar ist, gib 2 zurück und terminiere.
    \item Falls $n = p^a$ eine Primpotenz ist, gib die Primzahl $p$ zurück und terminiere.
    \item Bestimme eine zufällige Zahl $1 < a < n - 1$.
    \item Finde $g = ggT(a, n)$. Falls $g \neq 1$ ist, gib $g$ zurück und terminiere.
    \item Bestimme die Ordnung von $a$ modulo $n$ mit Hilfe des Quantenteils des Algorithmus:
    \begin{enumerate}
        \item Schätze die Phase des Operators $U_f$ ab, der $f(x) = ax$ implementiert mit einer Präzision von $m = 2\log_2(n)$ ab. Benutze dazu den in Kapitel 4.3 vorgestellten Algorithmus. Sei das Resultat $2^m\lambda$.
        \item Schätze den Quotienten $\frac{k}{r}$ von $\frac{2^m\lambda}{2^m}$ ab. Falls $r$ nicht die gesuchte Periode ist, gehe zurück zu (a), sonst gib die Periode $r$ zurück.
    \end{enumerate}
    \item Falls $r$ ungerade ist, gehe zurück zu 2. Sonst berechne $a^{\frac{r}{2}} \pmod{n}$. Falls dies kongruent zu $-1 \pmod{n}$ ist, gehe zurück zu 2.
    \item Berechne $b = (a^\frac{r}{2} + 1)$. Gib $\text{ggT}(b, n)$ zurück und terminiere.
\end{enumerate}
\subsection{Analyse des Algorithmus}
Wie in der EInführung bereits angetönt, liegt der grosse Vorteil dieses Algorithmus daran, dass er effizienter als alle auf klassischen Computern bekannten Algorithmen ist, wobei wir diesen Algorithmus als effizient bezeichnen, weil seine Laufzeit nicht direkt von der zu faktorisierenden Zahl abhängig ist, sondern nur von deren Logarithmus.
\paragraph{}
Sei $L$ die Anzahl Bits, die benötigt wird, um die zu faktorisierende Zahl $n$ abzuspeichern. In anderen Worten $L = \lceil \log 2(n) \rceil$. Die Laufzeit der meisten auf klassischen Computern bekannten Algorithmen sind exponentiell in $L$, während Shor's Algorithmus eine Laufzeit hat, die nur polynomiell in $L$ ist. 
\paragraph{}
Die Periodenabschätzungsfunktion ruft die mitgegebene Funktion $2L \in \mathcal O(L)$ mal auf. Diese mitgegebene Funktion ist die modulare Multiplikation, welche die Addition $\mathcal O(L)$ mal aufruft. Diese jedoch ruft die Fouriertransformation auf, welche eine $\mathcal O(L^2)$ Gatteroperationen benötigt. Multiplizieren wir dies zusammen, so bruacht die Periodenabschätzungsfunktion $\mathcal O(L^4)$ Gatteroperationen. Würde man an Stelle der auf der $QFT$-basierenden Addition die aus klassischen Schaltkreisen bekannte Addition verwenden, kann man diese Gatterzahl auf $\mathcal O(L^3)$ herunterbringen. Diese Periodenabschätzungsfunktion wird im Erwartungswert $\mathcal O(1)$ mal aufgerufen, was zu einer gesamten Laufzeit von $\mathcal O(L^4)$ führt.