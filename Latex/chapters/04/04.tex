\chapter{Der Weg zu Shor}
\section{Überblick}
In diesem Kapitel werden wir uns die notwendigen Konzepte und Ideen hinter dem quantenbasierten Teil von Shor's Algorithmus anschauen. Dabei starten wir beim simplen Konzept des "Phase Kickback"s, schauen uns dann die darauf basierende Phase Estimation an, bevor wir dann deren Anwendung in Period Finding anschauen. Zum Schluss werden wir uns dann die komplette Implementation vom quantenbasierten Teil von Shors Algorithmus anschauen und überprüfen.
\section{Phase-Kickback}
Beginnen wir den Abschnitt mit einer Frage: Wenn wir eie kontrollierte Operation ausführen, sollte sich das Control-Qubit eigentlich nicht ändern, oder? In diesem Abschnitt werden wir sehen, dass dies überraschender Weise nicht so ist. Dafür schauen wir uns das CNOT-Gate an. Was passirt, wenn wir CNOT auf zwei Qubits im State $\ket{+-}$ anwenden, mit dem ersten Qubit als Control-Qubit? Zuerst haben wir $\ket{+-} = \ket{00} - \ket{01} + \ket{10} - \ket{11}$, nachdem wir das CNOT anwenden bekommen wir den State $\ket{00} - \ket{01} - \ket{10} + \ket{11} = \ket{--}$. Überraschenderweise stellen wir fest, dass sich das Control-Qubit verändert hat, während das Ziel-Qubit gleich blieb. Was ist passiert? Nehmen wir das CNOT-Gate auseinander: Das CNOT-Gate ist eigentlich nichts anderes als eine kontrollierte Version vom $X$-Gate. Was passiert wenn wir das $X$-Gate auf den $\ket{-}$-State anwenden? $X\ket{-} = -\ket{0} + \ket{1} = -\ket{-} = (-1)*\ket{-}$. Hier können wir sehen, dass $\ket{-}$ ein Eigenvektor des $X$-Gates mit Eigenwert $-1$. Das heisst, der State des Qubits ändert sich nicht, es wird nur die Phase mit dem Eigenwert multipliziert. Da wir nur ein einzelnes Qubit anschauen, hat das keine Auswirkung, da die Phase global ist und wir dehalb keinen Unterschied feststellen können. Wenn wir aber die Operation kontrolliert durchführen, wird diese Phase nur in den States sichtbar, in der die Operation durchgeführt wird, sprich in den States, wo das Control-Qubit im State $\ket{1}$ ist. Dies konnten wir vorher beim CNOT-Gate beobachten. Schauen wir uns nun mal ein generelleres Gate an. Sagen wir, wir nehmen das Gate $U$ mit einem Eigenvektor $\ket{\psi}$ und dem Eigenwert $\lambda$. Nehmen wir jetzt ein Qubit $q_c$ im State $\alpha\ket{0} + \beta\ket{1}$, $n$ Qubits $q_0 ... q_{n-1}$ im State $\ket{\psi}$, und führen ein kontrolliertes $U$ auf die Qubits $q_0 ... q_{n-1}$ mit Kontroll-Qubit $q_c$ durch:
\begin{align*}
(\alpha\ket{0} + \beta\ket{1})\ket{\psi} \xrightarrow{\text{C-U}} \alpha\ket{0\psi} + \beta\ket{1}*U\ket{\psi} = (\alpha\ket{0} + \lambda\beta\ket{1})\ket{\psi}
\end{align*}
Das Ziel-Qubit verändert sich nicht, es ist ja ein Eigenvektor, dafür sehen wir, dass der Eigenwert in die Phase des Kontroll-Qubit gekickt wird. Daher kommt der Name "Phase Kickback". Wir werden in der nächsten Sektion sehen, wie dieser Effekt ausgenutz werden kann, um den Eigenwert eines Operators abzuschätzen.

\section{Phase Estimation}
Verschiedene Quanten-Algorithmen basieren darauf, den Eigenwert eines Operators zu einem Eigenvektor abzuschätzen. Dazu benutzen wir Phase-Kickbacks, um den Eigenwert in ein Quantum-Register in der Fourier-Basis zu schreiben, welches wir dann mit der inversen Quanten-Fouriertransformation in die binäre Basis zurückrechnen. Dazu können wir die Anzahl Qubits variieren, um die Präzision der Approximation festlegen. Besser gesagt gibt der Algorithmus zum Eigenwert $\lambda = e^{2i\pi\theta}$ die Zahl $2^n\theta$ zurück, wobei $n$ die Anzahl Qubits des Zählerregisters ist, die für bessere Präzision erhöht werden kann. 
\\
Um zu verstehen, wie dieser Algorithmus funktioniert, erinnern wir uns zuerst nochmals, wie eine Zahl in der Fourierbasis aussieht. Dafür benutzen wir nochmals die Bloch-Kugel. Wir erinnern uns, dass für die Zahl $x$ in der Fourierbasis mit $n$ Qubits das $k$-te Qubit um $\frac{2^kx}{2^n}$ um die Z-Achse gedreht wird. Das heisst, es befindet sich im Zustand $\frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi\frac{2^kx}{2^n}}\ket{1})$. Wir machen jetzt die Beobachtung, dass wir mit Hilfe von Phase-Kickback das gesuchte $\theta$ in der Fourierbasis in die Kontrollqubits schreiben können, da der Phase-Kickback nichts anderes macht, als das Kontrollqubit auf die selbe Art und Weise zu rotieren. Schauen wir uns mal an, was passert, wenn wir das kontrollierte $U$ $2^k$ mal anwenden:
\begin{align*}
\frac{1}{\sqrt{2}}(\ket{0} + \ket{1})\ket{\psi} \xrightarrow{(C-U)^{2^k}} \frac{1}{\sqrt{2}}(\ket{0\psi} + \ket{1}*U^{2^k}\ket{\psi}) \\ = \frac{1}{\sqrt{2}}(\ket{0} + (e^{2i\pi\theta})^{2^k}\ket{1})\ket{\psi} \\
= \frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi2^k\theta}\ket{1})\ket{\psi} \\
= \frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi\frac{2^k(2^n\theta)}{2^n}}\ket{1})\ket{\psi}
\end{align*}
Dies entspricht genau dem $k$-ten Qubit der Repräsentation von $2^n\theta$ in der Fourierbasis. Das heisst, wenn wir für jedes Qubit im Zählerregister mehrmals ein kontrolliertes $U$ anwenden, können wir einen Zustand kreieren, welcher der Zahl $2^n\theta$ in der Fourierbasis entspricht. Wenden wir dann die inverse Fouriertransformation an, können wir die Zahl $2^n\theta$ im Zählerregister ablesen. Falls $2^n\theta$ keine ganze Zahl ist, dann bekommen wir im Zählerregister eine Superposition, wobei eine Zahl wahrscheinlicher ist, je näher sie am echten Wert ist.

Um die Phase abzuschätzen, müssen wir also den Operator mehrmals hintereinander anwenden, zuerst nur einmal, dann zweimal, im $i$-ten Mal $2^i$ mal. Dies führt dazu, dass wir die Operation $2^n$ mal anwenden müssen. Allerdings ist es oft möglich, dass wir die Operation $U^{2^m}$ für einen beliebigen Parameter $m$ implementieren können. Wenn dies möglich ist, dann brauchen wir nur $n$ Anwendungen jener Operation.

\paragraph{Algorithmus}
\begin{enumerate}
    \item Initialisiere zwei Quantenregister, das Zählerregister und das Eigenstate-Register, und setze das Eigenstate-Register auf den gewünschten Eigenstate $\psi$.
    \item Wende $H^{\otimes n}$ auf das Zähler-Register an, um es auf $\ket{+}^{\otimes n}$ zu setzen.
    \item Für das $i$-te Bit im Zählerregister, wende ein kontrolliertes $U^{2^i}$ mit $c_i$ als Kontroll-Qubit an.
    \item Wende die inverse Quantenfouriertransformation auf das Zählerregister an, um die Approximation in die binäre Basis umzurechnen.
    \item Miss das Zählerregister, um die Abschätzung abzulesen.
\end{enumerate}
\input{./assets/circuits/4.3.1.crct} \newline

\section{Period Finding}
Gegeben sei eine Funktion $f : S \rightarrow S$ mit $S \subset \mathbb{Z}$, welche sich auf einem Quantencomputer implementieren lässt, und ein Wert $x \in S$. Wir versuchen nun, die kleinste Zahl $r \in \mathbb{N}$ zu berechnen, so dass $f^r(x) = x$ gilt. In anderen Worten: Sei $f_x(i) = f^i(x)$. Wir wollen nun die Periode von $f_x$ zu berechnen.

Wir haben gesagt, unsere Funktion soll auf einem Quantencomputer implementierbar sein. Daraus folgt bereits, dass $f$ bijektiv ist: Falls es ein $a$ und ein $b$ mit $f(a) = f(b) = c$ gibt, dann lässt sich $f^{-1}(c)$ nicht berechnen, was im Wiederspruch zur Reversibilität steht. Daraus folgt, dass $f$ injektiv ist. Gleichzeitig müssen deshalb $|S|$ verschiedene Bilder von $f$ existieren, damit jeder Wert ein eigenes Bild hat. Unsere Funktion permutiert die Elemente in $S$. Schaut man sich diese Permutation als Graph an, so hat jeder Knoten einen Eingangs- und einen Ausgangsgrad von 1. Dies ist jedoch nur möglich, wenn der Graph eine Vereinigung disjunkter Zyklen ist.
Dies bedeutet auch, dass man $S$ in verschiedene Teilmengen $S_0, S_1, ...$ aufteilen kann, so dass jede dieser Teilmengen ein einzelner Zyklus des Graphen bildet.
Sei nun $x \in S_i$. Da $S_i$ ein Zyklus bildet, gilt $f^{|S_i|}(x) = x$. Gleichzeitig kann kein $r \in \mathbb{N}$ mit $r < |S_i|$ existieren, so dass $f^r(x) = x$ gilt, denn sonst hätte unser Zyklus nur $r < |S_i|$ Elemente. Wir wollen nun also für ein $x \in S_i$ die Grösse $|S_i|$ finden.

Als Beispiel nehmen wir mal $g : A \rightarrow A$ mit $A = \mathbb{Z}/11\mathbb{Z}$, $g(x) = -x^3 + 1$. Man kann zeigen, dass $x^3 \pmod{p}$ bijektiv ist, falls $p \equiv 2 \pmod 3$. Somit ist auch $f$ bijektiv. Wenn wir den Graphen anschauen, dann sehen wir die einzelnen Zyklen: $A_0 = \{0, 1\}$, $A_1 = \{2, 3, 4, 7, 10\}$, $A_2 = \{5, 6, 8\}$ und $A_3 = \{9\}$. Wir sehen nun, dass $f^1(9) = 9$, $f^3(8) = 8$, $f^5(2) = 2$ etc. 

TODO Beispiel $f : \mathbb{Z} / 11 \mathbb{Z} \rightarrow \mathbb{Z} / 11 \mathbb{Z} $, $f(x) = -x^3 + 1$
\input{./assets/graphs/4.4.1.grph}

Die Frage ist nun, wie können wir effizient die Grösse der Teilmenge finden, in der $x$ sich befindet. Dafür müssen wir den Operator $f$ genauer betrachten. Was passiert, wenn wir dem Operator eine Superposition der Zahlen in $S_i$ übergeben? Seien $r = |S_i|$, $x_0, x_1, ..., x_{r - 1}$ die Zahlen in $S_i$, so dass $f(x_j) = x_{(j + 1) \% r}$, und $U_f$ die Quantenoperation, die $f$ implementiert. Schauen wir mal, was passiert, wenn wir $U_f$ auf den Zustand $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j}$ anwenden? Wir bekommen:
\begin{align*}
    U_f(\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j}) = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{f(x_j)} = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_{(j + 1) \% r}} = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j})
\end{align*}
Daraus schliessen wir, dass $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j}$ ein Eigenstate von $U_f$ mit Eigenwert $1$ ist. Dieser Eigenwert ist nicht wirklich interessant. Wir können ihn aber interessanter machen, indem wir den einzelnen Summanden eine Phase mitgeben. Dazu konstruieren wir die Superposition $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})$ für ein $k < r$. Was passiert, wenn wie $U_f$ darauf anwenden? 
\begin{align*}
    U_f(\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})) = \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_{(j + 1) \% r}}) = \\
    \frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{k(j - 1)}{r}}\ket{x_j}) = e^{2i\pi\frac{k}{r}}(\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j}))
\end{align*}
Auch hier haben wir wieder einn Eigenvektor, aber mit einem interessanterem Eigenwert, nämlich $e^{2i\pi\frac{k}{r}}$, denn $r$ ist im Eigenwert enthalten. Wir machen auch die Beobachtung, dass unser Eigenstate von vorher ($\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}\ket{x_j}$) auch von der Form ist, die wir gerade analysiert haben, einfach mit $k = 0$. Falls wir jetzt irgendwie einen State von der Form $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})$ erzeugen können, könnten wir mit Hilfe der Phase Estimation den Quotienten $\frac{k}{r}$ abschätzen. Die Frage ist, wie können wir solch einen State generieren? Zuerst sagen wir, $\ket{\psi_k}$ sei $\frac{1}{\sqrt{r}}\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})$. Dann stellen wir fest, dass $\ket{\psi_0}, \ket{\psi_1}, ..., \ket{psi_{r - 1}}$ linear unabhängig und damit eine Basis des Untervektorraums über die Zahlen $x_0, x_1, ..., x_{r - 1}$ sind. Was passiert nun, wenn wir alle diese Vektoren mit gleichem Gewicht aufsummieren?
\begin{align*}
    \frac{1}{\sqrt{r}}\sum_{k = 0}^{r - 1}\frac{1}{\sqrt{r}}(\sum_{j = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})) = \frac{1}{r}\sum_{j = 0}^{r - 1}\sum_{k = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j}) = \ket{x_0}
\end{align*}
Eine andere Art, dieses überraschende Resultat zu sehen, ist, dass man die Summe $\sum_{k = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j})$ für $j = 0$ anzuschauen. Da $j = 0$ gilt, gilt $e^{-2i\pi\frac{kj}{r}} = e^{0} = 1$ und somit $\sum_{k = 0}^{r - 1}(e^{-2i\pi\frac{kj}{r}}\ket{x_j}) = r\ket{x_j}$. Da $\frac{1}{r}(r\ket{x_j})$ bereits einen Betrag von $1$ hat, kann kein anderer Zustand mit positivem Betrag existieren, da die Beträge sich sonst zu etwas Grösserem als $1$ aufsummieren.

Somit ist $x_0$ einfach eine Superposition jener Eigenvektoren. Da wir der Periodenabschätzungsfunktion einen Startwert mitgeben, sei jener Startwert WLOG $x_0$, haben wir eine Superposition dieser Eigenvektoren. Schätzen wir somit den Eigenwert dieser Superposition ab, kollabiert sie in eine der Eigenvektoren, und wir bekommen einen Quotienten $\frac{k}{r}$ zurück, wobei jedes $k$ die gleiche Wahrscheinlichkeit hat. Genauer, bekommen wir die Zahl $2^n\frac{k}{r}$ zurück, wobei $n$ die Präzision ist, die wir dem Phase Estimation-Algorithmus mitgeben. Wir können mit Hilfe von Continued Fraction Expansion (TODO, deutsches Wort) den Quotienten $\frac{k}{r}$ vom Quotienten $\frac{2^n\frac{k}{r}}{2^n}$ abschätzen. Sobald wir den Bruch $\frac{k}{r}$ haben, wissen wir $r$, was die Zahl ist, die unsere Funktion zurückgeben soll. Nun kann es sein, dass $ggT(k, r) = g \neq 1$ ist, somit der Bruch mit $g$ gekürzt wird und wir dann als Resultat $\frac{r}{g}$ bekommen. 

TODO - Zeigen, dass das nicht zu oft passieren kann, die Eulersche Phi-Funktion einführen

\section{Die Ordnung von Zahlen bestimmen}
Der Algorithmus von Shor ist deshalb so schnell, da mit Hilfe des quantenbasierten Teils des Algorithmus die Ordnung einer Zahl schnell bestimmt werden kann. Sei $a$ die Zahl deren Ordnung wir Modulo der Zahl $n$ bestimmen wollen, so dass $ggT(a, n) = 1$.  Wir rechnen nun in $\mathbb{Z} / n \mathbb{Z}$. Da $ord_n(a)$ nichts anderes ist als die Periode der Funktion $g(x) = a^x$. Somit können wir die Funktion $f(x) = ax$ implementieren, so dass $f_s(x) = f^x(s) = sa^x$. Mit $s = 1$ bekommen wir dann $f_1(x) = f^x(1) = a^x$. Sei $U$ die Quantenoperation, die $f_1$ implementiert, dafür können wir einfach die Multiplikation aus der QInteger-Library verwenden. Gleichzeitig können wir auch $U^{2^i}$ effizient implementieren: $U^{2^i}$ ist nichts anderes als die Operation zu $f^{2^i}$. Da $f^{2^i}(x) = a^{2^i}x$, können wir ganz einfach $a^{2^i}$ klassisch berechnen und dann wieder die gewöhnliche Multiplikation aus der QInteger-Library verwenden. Wir können nun den Algorithmus aus dem vorherigen Kapitel verwenden, um die Periode der Funktion $f_1(x) = a^x$ abzuschätzen. Wir brauchen dafür nur noch eine Funktion, die $f(x) = a^x$ klassisch berechnet, um das Resultat überprüfen zu können, dafür kann man fast direkt FastPowMod aus der QInteger-Library verwenden. Dies führt dazu, dass der Code dieser Funktion nur sehr kurz ist.

\section{Das Ziel - Shors Algorithmus}
Wie erlaubt uns das nun, Zahlen zu faktorisieren? Sei $n$ die zu faktorisierende Zahl. Zuerst überprüfen wir, ob die Zahl durch 2 teilbar oder eine Primpotenz ist, und finden diese Faktoren entsprechend. Nun nehmen wir ein zufälliges $1 < a < n$. Falls $g = ggT(a, n) \neq 1$, dann haben wir bereits einen Teiler gefunden, nämlich $g$. Sonst sind $a$ und $n$ teilerfremd. Danach suchen wir die Ordnung von $a$ modulo $n$. Falls diese Ordnung ungerade ist, beginnen wir nochmals von vorne, sonst ist sie gerade. Sei diese Ordnung $r$. Mit $r$ können wir nun mit gewisser Wahrscheinlichkeit einen Teiler finden. Falls $a^{\frac{r}{2}} \not\equiv -1 \pmod n$ gilt, dann haben wir eine Wurzel von $1 \pmod{n}$ gefunden, sonst müssen wir es nochmals probieren. Da $r$ die Ordnung von $a$ ist, muss $a^{\frac{r}{2}}\not\equiv 1 \pmod{n}$ gelten. Nun gilt: $n | (a^\frac{r}{2} + 1)(a^\frac{r}{2} - 1)$, aber $n \not| \; a^\frac{r}{2} + 1$ und $n \not| \; a^\frac{r}{2} - 1$. Wir haben nun zwei Zahlen $b$ und $c$, sodass $n | bc$, aber $n \not | \; b$ und $n \not | \; c$. Sei $n = p_0^{\alpha_0}p_1^{\alpha_1}...$. Schreibe nun $b = s_bp_0^{\beta_0}p_1^{\beta_1}...$ und $b = s_cp_0^{\gamma_0}p_1^{\gamma_1}...$. Wir wissen nun, dass $\beta_i + \gamma_i \geq \alpha_i$ gelten muss, da sonst $n | bc$ nicht erfüllt wäre. Gleichzeitig müssen ein $j_b$ und ein $j_c$ existieren, so dass $\beta_{j_b} > 0$ und $\gamma_{j_c} > 0$ stimmt. Nehme an, dass ohne Beschrünkung der Allgemeinheit $\gamma_i = 0$ für alle $i$ gelte. Dann müsste $\beta_i \geq \alpha_i$ für alle $i$ gelten, und somit $n | b$ teilen, was ein Widerspruch zur Annahme $n \not | \; b$ wäre. Somit beinhalten beide Faktoren $b$ und $c$ Teiler von $n$, welche mit dem einfachen $ggT$-Algorithmus extrahiert werden können. Somit kennen wir nun den ganzen Algorithmus, um einen Teiler von $n$ zu finden.
\begin{enumerate}
    \item Falls $n$ durch zwei teilbar ist, gib 2 zurück und terminiere.
    \item Falls $n = p^a$ eine Primpotenz ist, gib die Primzahl $p$ zurück und terminiere.
    \item Bestimme eine zufällige Zahl $1 < a < n - 1$.
    \item Finde $g = ggT(a, n)$. Falls $g \neq 1$ ist, gib $g$ zurück und terminiere.
    \item Bestimme die Ordnung von $a$ modulo $n$ mit Hilfe des Quantenteils des Algorithmus:
    \begin{enumerate}
        \item Schätze die Phase des Operators $U_f$ ab, der $f(x) = ax$ implementiert mit einer Präzision von $m = 2\log_2(n)$ ab. Benutze dazu den in Kapitel 4.3 vorgestellten Algorithmus. Sei das Resultat $2^m\lambda$.
        \item Schätze den Quotienten $\frac{k}{r}$ von $\frac{2^m\lambda}{2^m}$ ab. Falls $r$ nicht die gesuchte Periode ist, gehe zurück zu (a), sonst gib die Periode $r$ zurück.
    \end{enumerate}
    \item Falls $r$ ungerade ist, gehe zurück zu 2. Sonst berechne $a^{r / 2} \pmod{n}$. Falls dies kongruent zu $-1 \pmod{n}$ ist, gehe zurück zu 2.
    \item Berechne $b = (a^\frac{r}{2} + 1)$. Gib $ggT(b, n)$ zurück und terminiere.
\end{enumerate}