\chapter{Grundlagen}
\section{Lineare Algebra}
Um mit Qubits arbeiten zu können, braucht es Kenntnisse der linearen Algebra. Operationen, die man auf Quantencomputern implementiert, sind lineare Operationen auf Qubits. Ich werde an dieser Stelle eine kurze Zusammenfassung der nötigen Grundlagen geben, welche erforderlich sind, um die Quanten-Grundlagen und Shors Algorithmus zu verstehen. Dies wird jedoch nur eine kurze Zusammenfassung und keine Einführung in dieses Gebiet sein. Für eine Einführung verweise ich auf \cite{LA}.

Vor der Zusammenfassung möchte ich kurz die in der Quantenmechanik gebräuchliche Notation für lineare Algebra einführen. Diese nennt sich Dirac- oder Bra-Ket-Notation. 

\subsection{Schreibweise}
Einen Vektor schreibt man in der Quantenmechanik als $\ket{\varphi}$. Diese besondere Art von Klammern wird als \textit{ket} bezeichnet. Für einen Vektor $\ket{\varphi}$ wird das dazugehörige Dual als $\bra{\phi}$ bezeichnet. Diese zweite Klammer heisst \textit{bra}, sodass die beiden Klammern zusammen ein Bra-Ket bildet, was vom englischen Wort bracket abstammt. Das später definierte innere Produkt von $\ket{\psi}$ und $\ket{\varphi}$ kann man als $\bra{\psi}\ket{\varphi}$ darstellen.

\subsection{Vektorräume}
Um Quantensysteme mathematisch beschreiben zu können, brauchen wir Vektorräume. Genauer benötigen wir finite Vektorräume über $\mathbb{C}$, zusammen mit einem inneren Produkt. Sei $V$ ein solcher Vektorraum. 

Wir nennen eine Familie von Vektoren ein \textit{Erzeugendensystem}, falls jeder Vektor in $V$ als eine Linearkombination der Vektoren in jener Familie geschrieben werden kann. Zum Beispiel sind die drei Vektoren $\begin{bmatrix}2 \\ 0\end{bmatrix}, \begin{bmatrix} 0 \\ 37\end{bmatrix}, \begin{bmatrix}3 \\ 2\end{bmatrix}$ ein Erzeugendensystem, denn zum Beispiel der Vektor $\begin{bmatrix}7 \\ 3\end{bmatrix}$ kann als Linearkombination $2\begin{bmatrix}2 \\ 0\end{bmatrix} + \frac{1}{37}\begin{bmatrix} 0 \\ 37\end{bmatrix} + \begin{bmatrix}3 \\ 2\end{bmatrix} = \begin{bmatrix}7 \\ 3\end{bmatrix}$ dargestellt werden.
\paragraph{}
Eine Familie von Vektoren $\ket{v_0}, \ket{v_1}, ... \ket{v_{k - 1}}$ ist \textit{linear unabhängig}, falls wenn für Koeffizienten $a_0, a_1, ... a_{k - 1}$ die Gleichung $a_0\ket{v_0} + a_1\ket{v_1} + ... + a_{k - 1}\ket{v_{k - 1}} = 0$ gilt, dann $a_0 = a_1 = ... = a_{k - 1} = 0$ gilt. Diese Aussage ist äquivalent zur Aussage, dass sich keiner der Vektoren $\ket{v_{i}}$ als Linearkombination der anderen Vektoren in der Familie darstellen lässt.

Die drei Vektoren $\begin{bmatrix}2 \\ 0\end{bmatrix}, \begin{bmatrix} 0 \\ 37\end{bmatrix}, \begin{bmatrix}3 \\ 2\end{bmatrix}$ sind nicht linear unabhängig, da $\frac{111}{2}\begin{bmatrix}2 \\ 0\end{bmatrix} + 2\begin{bmatrix} 0 \\ 37\end{bmatrix} + (-37)\begin{bmatrix}3 \\ 2\end{bmatrix} = 0$ gilt.
\paragraph{}
Eine \textit{Basis} ist ein linear unabhängiges Erzeugendensystem.
Zum Beispiel bilden die Vektoren $\begin{bmatrix}2 \\ 0\end{bmatrix}$ und $\begin{bmatrix}-1 \\ i\end{bmatrix}$ eine Basis über den Vektorraum $\mathbb{C}^2$.

\subsection{Inneres Produkt}
Am Anfang habe ich angetönt, dass wir dem Vektorraum ein inneres Produkt $(\cdot,\cdot)$ mitgeben werden. Dieses innere Produkt muss folgende drei Bedingungen erfüllen: 
\begin{enumerate}
    \item Linear im zweiten Argument: $$\sum_j\lambda_j\left(\ket{\psi}, \; \ket{\varphi_j}\right) = \left(\ket{\psi}, \; \sum_j\lambda_j\ket{\varphi_j}\right)$$
    \item Hermitesch: $$\left(\ket{\psi}, \; \ket{\varphi} \right) = \overline{\left(\ket{\varphi} , \; \ket{\psi}\right)}$$
    \item Positiv-definit: $$\varphi \neq 0 \rightarrow \left( \ket{\varphi}, \; \ket{\varphi} \right) > 0$$
\end{enumerate}
Wie oben schon angetönt, schreibt man dieses Produkt in der quantenmechanischen Notation als $\bra{\psi}\ket{\varphi}$. Ich habe für diese drei Bedingungen jedoch die $(\cdot, \cdot)$-Schreibweise verwendet, da man mit ihr die Bedingungen übersichtlicher darstellen kann.

Die \textit{Norm} eines Vektors $\ket{\varphi}$, wird als $\left\| \ket{\varphi} \right\|$ geschrieben und ist definiert als $\left\| \ket{\varphi} \right\| = \sqrt{\bra{\varphi}\ket{\varphi}}$. Ein Vektor $\ket{\varphi}$ ist normiert, falls $\left| \ket{\varphi} \right| = 1$ gilt.

\subsection{Lineare Operatoren}
Die Operationen, die wir auf Quantencomputer durchführen, sind lineare Operationen über die Basiszustände. Lineare Operatoren über Vektoren kann man als Matrizen darstellen und jene Operationen anwenden, in dem wir die Matrix-Multiplikation des Vektors mit der Matrix des linearen Operators durchführt.

Eine unitärer Operator $U$ ist ein linearer Operator, der $UU^{\dagger} = I$ erfüllt. Ein unitärer Operator hat die Eigenschaft, dass das innere Produkt bewahrt wird, oder dass $(U\ket{\psi}, U\ket{\varphi}) = \bra{\psi}U^{\dagger}U\ket{\varphi} = \bra{\psi}\ket{\varphi}$ für alle $\ket{\psi}, \ket{\varphi} \in V$. Auch hier habe ich auf der linken Seite die mathematische Schreibweise verwendet, um es verständlicher darzustellen. Die beiden Bedingungen, dass $UU^{\dagger} = 1$ gilt und dass das innere Produkt bewahrt wird, sind äquivalent. Wir stellen auch fest, dass da das innere Produkt bewahrt wird, wird auch das innere Produkt eines Vektors mit sich selbst bewahrt, und somit auch die Norm eines Vektors.

\subsection{Eigenwerte und Eigenvektoren}
Ein Eigenvektor $\ket{\varphi}$ zu einem linearen Operator $U$ ist ein Vektor, sodass $U\ket{\varphi} = \lambda\ket{\varphi}$ gilt, wobei $\lambda$ als der dazugehörige Eigenwert bezeichnet wird und eine Zahl ist. Bei einer unitären Matrix muss der Eigenwert einen Betrag von 1 haben, denn sonst würde sich die Norm verändern. Der grosse Vorteil von Eigenvektoren ist, dass sie sich nicht verändern, wenn der dazugehörige Operator auf ihnen angewandt wird.

\section{Quantensysteme}
Die Quantensysteme, die wir im Bereich der Quantencomputer betrachten, sind rein mathematische Systeme, die nicht an eine fixe physikalische Realisierung gebunden sind. In der Tat gibt es verschiedene Möglichkeiten, solche Systeme umzusetzen, wobei jedes System eigene Vor- und Nachteile hat.

\subsection{Qubits}
Starten wir beim klassischen Bit. Ein klassisches Bit hat genau zwei Zustände - 0 und 1 - und ist immer in genau einem dieser beide Zustände. Ein Qubit hat auch die beiden Basiszustände $\ket{0}$ und $\ket{1}$, im Gegensatz zu einem klassischen Bit kann es aber auch beides gleichzeitig sein. Dies nennt man eine Superposition. 

\textbf{Definition:} Ein \textit{Qubit} ist ein Quantensystem mit den beiden Basiszuständen $\ket{0}$ und $\ket{1}$. Es kann alle Zustände $\alpha\ket{0} + \beta\ket{1}$ annehmen, sodass $\abs{a}^2 + \abs{b}^2 = 1$ gilt.

Ein Zustand des Qubits, welcher durch die Parameter $\alpha$ und $\beta$ definiert ist, entspricht einem normierten Vektor im Vektorraum $\mathbb{C}^2$.

Dieses Qubit können wir messen. Die Wahrscheinlichkeit, dass wir $\ket{0}$ messen beträgt $\abs{\alpha}^2$, und die Wahrscheinlichkeit, $\ket{1}$ zu messen, beträgt $\abs{\beta}^2$. Die Bedingung, dass $\abs{a}^2 + \abs{b}^2 = 1$ gelten muss, führt in diesem Fall dazu, dass sich die Wahrscheinlichkeiten auf $1$ summiern. Nach der Messung kollabiert das Quantensystem in den gemessenen Zustand. Messen wir also $\ket{1}$, befindet sich das Qubit nachher immer im Zustand $\ket{1}$, unabhängig davon, was $\alpha$ und $\beta$ vorher waren.

Ähnlich entspricht der Zustand eines Multiqubitsystems mit $n$ Qubits einen normierten Vektor im Vektorraum $\mathbb{C}^{2^n}$. Die Basiszustände des Vektorraums entsprechen dabei den einzelnen Kombinationen der $\ket{0}$s und $\ket{1}$s der einzelnen Qubits. Zum Beispiel hat der Vektorraum zu einem Quantensystem mit 2 Qubits die vier Basiszustände $\ket{00}, \ket{01}, \ket{10}$ und $\ket{11}$. Der Bitstring von Länge $n$ innerhalb dem Ket, entspricht dabei der Konfiguration der Qubits. Der Zustand $\ket{101}$ in einem System mit 3 Qubits entspricht dem Zustand, in welchem das erste Qubit im Zustand $\ket{1}$, das zweite im Zustand $\ket{0}$ und das dritte im Zustand $\ket{1}$ ist. Anstelle des Bitstrings wird innerhalb des Kets auch oft eine Zahl verwendet, welche in der Binärdarstellung diesen Bitstring ergibt. Zum Beispiel entspricht $\ket{5}$ dem Zustand $\ket{101}$.

Ein Zustand ist nun ein normierter Vektor im Vektorraum $\mathbb{C}^{2^n}$. Der Eintrag des Basiszustands $\ket{j}$ entspricht dabei der Wahrscheinlichkeit, den Zustand $j$ zu messen. Auch hier summmieren sich die Wahrscheinlichkeiten wieder auf 1, da der Vektor normiert ist. Auch hier schreibt man die Zustände auch oft wieder als eine Linearkombiantion der Basiszustände: $\alpha_{00}\ket{00} + \alpha_{01}\ket{01} + \alpha_{10}\ket{10} + \alpha_{11}\ket{11} = \alpha_{0}\ket{0} + \alpha_{1}\ket{1} + \alpha_{2}\ket{2} + \alpha_{3}\ket{3}$.

Falls wir nur einzelne Qubits messen, kollabiert das System in die restlichen, noch möglichen Zustände. Nehmen wir als Beispiel ein 2-Qubit-System im Zustand $\frac{1}{\sqrt{6}}\ket{00} + \frac{1}{\sqrt{2}}\ket{01} + \frac{1}{\sqrt{3}}\ket{11}$ und messen das erste Qubit. Die Wahrscheinlichkeit, dass wir dieses Qubit im Zustand $\ket{1}$ messen, liegt bei $\abs*{\alpha_{10}}^2 + \abs*{\alpha_{11}}^2 = \frac{1}{3}$. Falls wir diesen Zustand messen, kollabiert unser Quantensystem sofort in den Zustand $\frac{\alpha_{10}\ket{10} + \alpha_{11}\ket{11}}{\sqrt{\abs*{\alpha_{10}}^2 + \abs*{\alpha_{11}}^2}} = \ket{11}$, wobei der Nenner dafür sorgt, dass der neue Quantenzustand wieder normiert ist. Die Wahrscheinlichkeit eines $\ket{0}$ in der Messung des ersten Qubit hingegen liegt bei $\abs*{\alpha_{00}}^2 + \abs*{\alpha_{01}}^2 = \frac{2}{3}$. Der Zustand des Systems nach der Messung ist dann $\frac{\alpha_{00}\ket{00} + \alpha_{01}\ket{01}}{\sqrt{\abs*{\alpha_{00}}^2 + \abs*{\alpha_{01}}^2}} = \sqrt{\frac{1}{4}}\ket{00} + \sqrt{\frac{3}{4}}\ket{01}$.

\subsection{Die Blochkugel}
Die Blochkugel dient der graphischen Darstellung des Zustands eines einzelnen Qubits. Zu diesem Zweck nehmen wir noch einmal ein einzelnes Qubit $\alpha\ket{0} + \beta\ket{1}$ mit $\abs*{\alpha}^2 + \abs*{\beta}^2 = 1$. Diese Bedingung führt dazu, dass wir den Zustand als $e^{i\gamma}\left(cos\frac{\theta}{2}\ket{0} + e^{i\varphi}sin\frac{\theta}{2}\ket{1}\right)$ umschreiben können. Den Faktor $e^{i\gamma}$ können wir nicht beobachten, da er auf beide Koeffizienten wirkt. Deshalb ist der Zustand durch die beiden Winkel $\theta$ und $\varphi$ definiert. Diese beiden Winkel kann man graphisch als einen Punkt auf einer Einheitskugel darstellen. Diese Darstellung wird die Bloch-Kugel genannt.

\begin{tikzpicture}
    \def\radius{3}
    \draw (0,0) node[circle,fill,inner sep=1] (center) {} -- (\radius/3,\radius/2) node[circle,fill,inner sep=0.7,label=above:$\alpha\ket{0} + \beta\ket{1}$] (pnt) {};
    \draw[dashed] (center) -- (\radius/3,-\radius/5) node (phi) {} -- (pnt);
    \draw (center) circle (\radius);
    \draw[dashed] (center) ellipse (\radius{} and \radius/3);
    \draw[->] (center) -- ++(-\radius/5,-\radius/3) node[below] (xaxis) {$x$};
    \draw[->] (center) -- ++(\radius,0) node[right] (yaxis) {$y$};
    \draw[->] (center) -- ++(0,\radius) node[above] (zaxis) {$z$};
    \pic [draw=black,text=black,->,"$\phi$"] {angle = xaxis--center--phi};
    \pic [draw=black,text=black,<-,"$\theta$"] {angle = pnt--center--zaxis};
\end{tikzpicture}

\subsection{Operationen auf Qubits}
Operationen, die man auf Qubits implementiert, sind lineare Operationen und lassen sich somit als Matrizen darstellen. Man kann den Zustandsvektor mit der Matrix des Operators multiplizieren, um den Zustand nach der Operation zu erhalten. Dazu müssen die Operatoren die Norm des Quantenzustands bewahren, da die Zustände immer normiert sein müssen, und somit unitär sein. Dies hat die direkte Konsequenz (für eine unitäre Matrix $U$ gilt $UU^{\dagger} = I$), dass ein inverser Operator existieren muss und deshalb alle Berechnungen reversibel sein müssen. Beispielsweise kann der Modulo Operator nicht auf Quantencomputern implementiert werden, da man aus dem Ergebnis $x \equiv 2 \pmod{3}$ die Eingabe $x \in \{2, 5, 8\cdots\}$ nicht eindeutig wiederherstellen kann. Dies hat grosse Konsequenzen für die Berechnungen auf Quantencomputern. Gleichzeitig stellt sich heraus, dass sich alle unitären Matrizen beliebig annähern lassen. Die Konstruktion dazu kann man in \cite{QC}, Seiten 188ff., nachlesen.

\subsection{Wichtige Quantengatter}
An dieser Stelle werden kurz die wichtigsten Quantengatter eingeführt, die wir benötigen werden. Zuerst betrachten wir 5 grundlegende Gatter auf Qubits: die 3 Pauli-Matrizen, das $H$-Gatter und das $CNOT$-Gatter.
\begin{itemize}
    \item Das $X$-Gatter ist das Qubit-Equivalent zum $NOT$-Gatter. In Matrixform sieht der Operator so aus: $ X = \begin{bmatrix}0 & 1 \\ 1 & 0\end{bmatrix}$. Dieses Gatter dreht den Zustand des Qubits um $\pi$ um die $x$-Achse in der Blochkugel.
    \item Das $Y$-Gatter implementiert die Operation der Matrix $Y = \begin{bmatrix}0 & -i \\ i & 0\end{bmatrix}$. Dieses Gatter entspricht einer Rotation von $\pi$ um die $y$-Achse in der Blochkugel.
    \item Das $Z$-Gatter, als Matrix $Z = \begin{bmatrix}1 & 0 \\ 0 & -1\end{bmatrix}$, dreht den Zustand um $\pi$ um die $z$-Achse.
    \item Das $H$-Gatter ist der einfachste Weg, eine Superposition zu erzeugen. Mit der Matrix $H = \frac{1}{\sqrt{2}}\begin{bmatrix}1 & 1 \\ 1 & -1\end{bmatrix}$ kann man die beiden Zustände $H\ket{0} = \frac{1}{\sqrt{2}}(\ket{0} + \ket{1})$ und $H\ket{1} = \frac{1}{\sqrt{2}}(\ket{0} - \ket{1})$ erzeugen. Diese beiden Zustände kommen so häufig vor, dass man ihnen die Namen $\ket{+} = \frac{1}{\sqrt{2}}(\ket{0} + \ket{1})$ und $\ket{-} = \frac{1}{\sqrt{2}}(\ket{0} - \ket{1})$ gegeben hat.
    \item $CNOT$ steht als Abkürzung für "Controlled NOT". Dieses Gatter wirkt auf zwei Qubits und wendet ein $NOT$ auf das zweite Qubit an, wenn das erste Qubit auf $1$ ist. Als Matrix sieht die Operation so aus: $CNOT = \begin{bmatrix}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0\end{bmatrix}$.
\end{itemize}
Diese Gatter gehören zu den wichtigsten Gattern im Bereich der Quantencomputer. Wir werden auf unserem Weg jedoch weitere Gatter antreffen. Eines, von welchem wir noch mehr Gebrauch machen werden, möchte ich hier kurz definieren. Ich nenne es $Rot(k)$ und in Matrix-Form sieht es so aus: $Rot(k) = \begin{bmatrix}1 & 0 \\ 0 & e^{\frac{2i\pi}{2^k}}\end{bmatrix}$. Dieses Gatter multipliziert den Koeffiztienten von $\ket{1}$ mit $e^{\frac{2i\pi}{2^k}}$ und wir werden es bei der Quanten-Fouriertransformation und dessen Anwendungen antreffen.

Abschliessend möchte ich noch ein Gatter auf zwei Qubits erwähnen, bekannt als das SWAP-Gatter. Dieses Gatter wechselt die Zustände der beiden Qubits. Es implementiert die Matrix: $$ SWAP = \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} = \begin{bmatrix}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0\end{bmatrix} \begin{bmatrix}0 & 1 & 0 & 0 \\ 1 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0\end{bmatrix}$$
Die rechte Seite zeigt uns, dass wir $SWAP(A, B)$ als $CNOT(A, B)$, $CNOT(B, A)$ und $CNOT(A, B)$ implementieren können.