\chapter{Grundlagen}
\section{Lineare Algebra}
Um mit Qubits arbeiten zu können, braucht man einige Fakten der linearen Algebra. Die Operationen, die man auf Quantencomputer implementiert, sind lineare Operationen auf den Qubits. Ich werde hier eine kurze Zusammenfassung der nötigen Grundlagen geben, die benötigt werden, um die Quanten-Grundlagen und Shors Algorithmus zu verstehen. Davor möchte ich noch kurz die in der Quantenmechanische gebräuchliche Notation für lineare Algebra einführen. Diese nennt sich Dirac- oder Bra-Ket-Notation. 

\subsection{Schreibweise}
Ein Vektor schreibt man in der Quantenmechanik als $\ket{\varphi}$. Dieses speziellere Art von Klammern wird als \textit{ket} bezeichnet. Für einen Vektor $\ket{\varphi}$ wird das dazugehörige Dual als $\bra{\phi}$ bezeichnet. Diese Klammer heisst \textit{bra}, so dass die beiden Klammern zusammen ein Bra-Ket bildet, was vom englischen Wort bracket abstammt. Zudem kann man das später definierte innere Produkt von $\ket{\psi}$ und $\ket{\varphi}$ als $\bra{\psi}\ket{\varphi}$.

\subsection{Hilberträume}
Ein \textit{Hilbertraum} ist ein Vektorraum über die reellen oder komplexen Zahlen kombiniert mit einem Skalarprodukt, der noch gewisse andere mathemathematische Eigenschaften besitzt, auf die wir hier nicht weiter eingehen. Sei $H$ ein Hilbertraum, und sei $\ket{u_0}, \ket{u_1}, \ket{u_2}, ..., \ket{u_{k - 1}} \in H$ eine Familie von Vektoren in jenem Hilbertraum. Diese Vektoren bilden ein \textit{Erzeugendensystem}, falls jeder Vektor in $H$ als eine Linearkombination der Vektoren in jener Familie geschrieben werden kann. Zum Beispiel sind die drei Vektoren $\begin{bmatrix}2 \\ 0\end{bmatrix}, \begin{bmatrix} 0 \\ 37\end{bmatrix}, \begin{bmatrix}3 \\ 2\end{bmatrix}$ ein Erzeugendensystem über den Hilbertraum $\mathbb{R}^2$, denn zum Beispiel der Vektor $\begin{bmatrix}7 \\ 3\end{bmatrix}$ kann als Linearkombination $2\begin{bmatrix}2 \\ 0\end{bmatrix} + \frac{1}{37}\begin{bmatrix} 0 \\ 37\end{bmatrix} + \begin{bmatrix}3 \\ 2\end{bmatrix} = \begin{bmatrix}7 \\ 3\end{bmatrix}$ dargestellt werden.

Eine Familie von Vektoren $\ket{u_0}, \ket{u_1}, \ket{u_2}, ..., \ket{u_{k - 1}} \in H$ ist \textit{linear unabhängig}, falls keine Koeffizienten $c_0, c_1, ..., c_{k - 1}$ existieren, die nicht alle gleichzeitig $0$ sind, so dass $c_0\ket{u_0} + c_1\ket{u_1} + c_2\ket{u_2} + ... + c_{k - 1}\ket{u_{k - 1}} = 0$ ist (wobei in der letzten Gleichung 0 den Nullvektor über $H$ ausdrückt). Eine \textit{Basis} ist ein linear unabhängiges Erzeugendensystem. Die drei Vektoren $\begin{bmatrix}2 \\ 0\end{bmatrix}, \begin{bmatrix} 0 \\ 37\end{bmatrix}, \begin{bmatrix}3 \\ 2\end{bmatrix}$ sind nicht linear unabhängig, da $\frac{111}{2}\begin{bmatrix}2 \\ 0\end{bmatrix} + 2\begin{bmatrix} 0 \\ 37\end{bmatrix} + (-37)\begin{bmatrix}3 \\ 2\end{bmatrix} = 0$ gilt. Die beiden Vektoren $\begin{bmatrix}2 \\ 0\end{bmatrix}, \begin{bmatrix}3 \\ 2\end{bmatrix}$ hingegen sind linear unabhängig und gleichzeitig ein Erzeugendensystem, und bilden darum zusammen eine Basis des Vektorraums $\mathbb{R}^2$.

Ein Hilbertraum benötigt auch ein inneres Produkt $\left( \cdot, \cdot \right)$. Dieses innere Produkt soll drei Bedingungen erfüllen:
\begin{enumerate}
    \item Linearität im zweiten Argument: $$\sum_j\lambda_j\left(\ket{\psi}, \; \ket{\varphi_j}\right) = \left(\ket{\psi}, \; \sum_j\lambda_j\ket{\varphi_j}\right)$$
    \item Hermetisch: $$\left(\ket{\psi}, \; \ket{\varphi} \right) = \overline{\left(\ket{\varphi} , \; \ket{\psi}\right)}$$
    \item Positiv-definit: $$\varphi \neq 0 \rightarrow \left( \ket{\varphi}, \; \ket{\varphi} \right) > 0$$
\end{enumerate}
Hier habe ich mich entschieden, zuerst die mathematische Schreibweise einzuführen, da man mit dieser die drei Bedingungen übersichtlicher darstellen kann. In der quantenmechanischen Schreibweise wird das innere Produkt von $\psi$ und $\varphi$ als $\bra{\phi}\ket{\varphi}$ dargestellt, und ich werde vor allem die quantenmechanische Schreibweise verwenden.

Mit Hilfe dieses Skalarprodukt können wir die Norm eines Vektors $v$ als $\left\| v \right\| = \sqrt{\langle v, v \rangle}$. Man sagt, ein Vektor $v$ ist normiert, wenn $\left\| v \right\| = 1$ gilt.

Ein \textit{linearer Operator} $U$ von einem Vektorraum $V$ zu einem anderen Vektorraum $W$ ist ein Operator, der in all seinen Eingaben linear ist, und somit die Gleichung $$U(\sum_j{\lambda_j v_j}) = \sum_j\lambda_j U(v_j)$$
\section{Quantensysteme}
\subsection{Qubits}
Die Quantensysteme, die wir im Bereich des Quantum Computing betrachten, sind rein mathemathematische Systeme, die auf keiner fixen physikalische Realisierung basieren. Dies bedeutet, dass es verschiedene physische Implementierungen gibt, die sich je nach Situation besser oder weniger gut eignen.

\textbf{Definition 2.2.1:} Ein \textbf{Qubit} ist das kleinste Quantensystem und damit die kleinste Informationseinheit in einem Quantencomputer. Das System hat die beiden Basiszustände $\ket{0}$ und $\ket{1}$ und kann somit alle Zustände $\alpha\ket{0} + \beta\ket{1}$ mit $\abs*{\alpha}^2 + \abs*{\beta}^2 = 1$ annehmen.

Falls $\alpha$ und $\beta$ beide nicht 0 sind, ist das Qubit "gleichzeitig" $\ket{0}$ und $\ket{1}$. Dies nennt man eine Superposition. 

Den Zustand $\alpha\ket{0} + \beta\ket{1}$ kann man auch mit einem Vektor $\begin{bmatrix}\alpha \\ \beta\end{bmatrix}$ darstellen. Die Bedingung, dass $\abs*{\alpha}^2 + \abs*{\beta}^2 = 1$ gelten muss, bedeutet, dass der Vektor normiert sein muss. Die Chance, den Zustand $\ket{0}$ zu messen, beträgt $\abs*{\alpha}^2$, und für den Zustand $\ket{1}$ beträgt sie $\abs*{\beta}^2$. Hier sehen wir wieder, dass der Vektor normiert sein muss, sonst würden sich die Wahrscheinlichkeiten nicht auf 1 summieren.
Genereller lassen sich Zustände, die $n$ Qubits involvieren, als Vektoren von Grösse $2^n$ darstellen. Sei $a_j$ der $j$-te Eintrag in jenem Vektor. Die Chance, den Zustand $j$ zu messen, wobei das $k$-te Qubit dann im Zustand $\lfloor \frac{j}{2^k} \rfloor \pmod{2}$ ist (was einfach dem $k$-ten Bit in der Binärdarstellung von $j$ entspricht), ist dann $\abs*{\alpha_j}^2$. Auch hier summieren sich die Wahrscheinlichkeiten auf 1, da der Vektor normiert ist. Man kann diese Zustände aber auch in Form eines mathematischen Ausdrucks $\alpha_0\ket{0} + ... + \alpha_j\ket{j} + ... + \alpha_{2^n - 1}\ket{2^n - 1}$ oder $\alpha_{00\dots}\ket{00\dots} + ... + \alpha_{j}\ket{j} + ... + \alpha_{11\dots}\ket{11\dots}$ darstellen, wobei in der zweiten Schreibweise $j$ ein Bitstring von Länge $n$ ist.

Wenden wir uns wieder einem einzelnen Qubit im Zustand $\alpha\ket{0} + \beta\ket{1}$ zu. Wir wissen bereits, dass wir bei einer Messung mit einer Wahrscheinlichkeiten von $\abs*{\alpha}^2$ den Zustand $\ket{0}$ messen. Nach dieser Messung kollabiert das Quantensystem in den gemessenen Zustand. Das heisst, messen wir den Zustand $\ket{0}$, befindet sich das Quantensystem nachher im Zustand $\ket{0}$, egal, wie $\alpha$ und $\beta$ vorher waren. Dies gilt auch für Multi-Qubit Systeme. Diese kollabieren dann in die noch möglichen Quantenpositionen. Nehmen wir als Beispiel ein 2-Qubit-System im Zustand $\frac{1}{\sqrt{6}}\ket{00} + \frac{1}{\sqrt{2}}\ket{01} + \frac{1}{\sqrt{3}}\ket{11}$ und messen das erste Qubit. Die Chance, dass wir dieses Qubit im Zustand $\ket{1}$ messen, liegt bei $\abs*{\alpha_{10}}^2 + \abs*{\alpha_{11}}^2 = \frac{1}{3}$. Falls wir diesen Zustand messen, kollabiert unser Quantensystem sofort in den Zustand $\frac{\alpha_{10}\ket{10} + \alpha_{11}\ket{11}}{\sqrt{\abs*{\alpha_{10}}^2 + \abs*{\alpha_{11}}^2}} = \ket{11}$, wobei die Summe im Nenner dafür sorgt, dass der neue Quantenzustand wieder normalisiert ist. Die Chance eines $\ket{0}$ in der Messung des ersten Qubit hingegen liegt bei $\abs*{\alpha_{00}}^2 + \abs*{\alpha_{01}}^2 = \frac{2}{3}$. Der Zustand des Systems nach der Messung ist dann $\frac{\alpha_{00}\ket{00} + \alpha_{01}\ket{01}}{\sqrt{\abs*{\alpha_{00}}^2 + \abs*{\alpha_{01}}^2}} = \sqrt{\frac{1}{4}}\ket{00} + \sqrt{\frac{3}{4}}\ket{01}$.
Dass diese Zustände rein mathematisch durch Vektoren darstellen lassen, hat zur Folge, dass man Quanten verschränken kann. Dafür schauen wir uns den einfach realisierbaren Zustand $\frac{1}{\sqrt{2}}(\ket{00} + \ket{11})$. Nun platzieren wir das eine Qubit auf die eine Seite des Universums, und das andere Qubit auf die andere Seite. Dann messen wir das erste Qubit. Die beiden Zustände $\ket{0}$ und $\ket{1}$ haben dabei die gleiche Wahrscheinlichkeit. Das andere Qubit auf der anderen Seite des Universums, kollabiert darauf sofort in den gleichen Zustand wie das erste. Ich habe dabei die beiden Seiten des Universums gewählt, um darauf aufmerksam zu machen, dass diese Qubits miteinander verknüpft sind, und dabei physikalische Distanz keine Rolle spielt.

\subsection{Die Blochkugel}
Die Blochkugel dient der graphischen Darstellung des Zustands eines einzelnen Qubits. Dazu nehmen wir noch einmals ein einzelnes Qubit $\alpha\ket{0} + \beta\ket{1}$ mit $\abs*{\alpha}^2 + \abs*{\beta}^2 = 1$. Diese Bedingung führt dazu, dass wir den Zustand als $e^{i\gamma}\left(cos\frac{\theta}{2}\ket{0} + e^{i\varphi}sin\frac{\theta}{2}\ket{1}\right)$ umschreiben können. Den Faktor $e^{i\gamma}$ können wir nicht beobachten, da er auf beide Koeffizienten wirkt. Deshalb ist der Zustand durch die beiden Winkel $\theta$ und $\varphi$ definiert. Diese beiden Winkel kann man graphish als einen Punkt auf der Einheitskugel darstellen.

\begin{tikzpicture}
    \def\radius{3}
    \draw (0,0) node[circle,fill,inner sep=1] (center) {} -- (\radius/3,\radius/2) node[circle,fill,inner sep=0.7,label=above:$\alpha\ket{0} + \beta\ket{1}$] (pnt) {};
    \draw[dashed] (center) -- (\radius/3,-\radius/5) node (phi) {} -- (pnt);
    \draw (center) circle (\radius);
    \draw[dashed] (center) ellipse (\radius{} and \radius/3);
    \draw[->] (center) -- ++(-\radius/5,-\radius/3) node[below] (xaxis) {$x$};
    \draw[->] (center) -- ++(\radius,0) node[right] (yaxis) {$y$};
    \draw[->] (center) -- ++(0,\radius) node[above] (zaxis) {$z$};
    \pic [draw=black,text=black,->,"$\phi$"] {angle = xaxis--center--phi};
    \pic [draw=black,text=black,<-,"$\theta$"] {angle = pnt--center--zaxis};
\end{tikzpicture}

\subsection{Operationen auf Qubits}
Die Operationen, die man auf Qubits implementiert, sind lineare Operationen und lassen sich somit als Matrizen darstellen. Man kann den Zustandsvektor mit der Matrix des Operators multiplizieren, um den Zustand nach der Operation zu erhalten. Desweiteren entwickeln sich Quantensysteme gemäss einem Postulat der Quantenmechanik die Schrödingergleichung erfüllend, was dazu führt, dass die implementierten Operatoren unitär sein müssen. Dies hat die direkte Konsequenz (für eine unitäre Matrix $U$ gilt $UU^{\dagger} = I$), dass ein inverser Operator existieren muss und deshalb alle Berechnungen reversibel sein müssen. Beispielsweise kann der Modulo Operator nicht auf Quantencomputern implementiert werden, da man aus dem Ergebnis $x \equiv 2 \pmod{3}$ die Eingabe $x \in \{2, 5, 8\cdots\}$ nicht eindeutig wiederherstellen kann. Dies hat grosse Konsequenzen für die Berechnungen auf Quantencomputern. Gleichzeitig stellt sich heraus, dass sich alle unitären Matrizen beliebig annähern lassen. Die Konstruktion dazu kann man in [QC], Seiten 188ff., nachlesen.

\subsection{Wichtige Quantengatter}
Hier sollen kurz die wichtigsten Quantengatter eingeführt werden, die wir benötigen werden. Zuerst schauen wir uns 5 grundlegende Gatter auf Qubits an, die 3 Pauli-Matrizen, das $H$-Gatter und das $CNOT$-Gatter.
\begin{itemize}
    \item Das $X$-Gatter ist das Qubit-Equivalent zum $NOT$-Gatter. In Matrixform sieht der Operator so aus: $ X = \begin{bmatrix}0 & 1 \\ 1 & 0\end{bmatrix}$. Dieses Gatter dreht den Zustand des Qubits um $\pi$ um die $x$-Achse in der Blochkugel.
    \item Das $Y$-Gatter implementiert die Operation der Matrix $Y = \begin{bmatrix}0 & -i \\ i & 0\end{bmatrix}$. Dieses Gatter entspricht einer Rotation von $\pi$ um die $y$-Achse in der Blochkugel.
    \item Das $Z$-Gatter, als Matrix $Z = \begin{bmatrix}1 & 0 \\ 0 & -1\end{bmatrix}$, dreht den Zustand um $\pi$ um die $z$-Achse.
    \item Das $H$-Gatter ist der einfachste Weg, eine Superposition zu erzeugen. Mit der Matrix $H = \frac{1}{\sqrt{2}}\begin{bmatrix}1 & 1 \\ 1 & -1\end{bmatrix}$ kann man die beiden Zustände $H\ket{0} = \frac{1}{\sqrt{2}}(\ket{0} + \ket{1})$ und $H\ket{1} = \frac{1}{\sqrt{2}}(\ket{0} - \ket{1})$ erzeugen. Diese beiden Zustände kommen so häufig vor, dass man ihnen die Namen $\ket{+} = \frac{1}{\sqrt{2}}(\ket{0} + \ket{1})$ und $\ket{-} = \frac{1}{\sqrt{2}}(\ket{0} - \ket{1})$ gegeben hat.
    \item $CNOT$ steht als Abkürzung für "Controlled NOT". Dieses Gatter wirkt auf zwei Qubits und wendet ein $NOT$ auf das zweite Qubit an, wenn das erste Qubit auf $1$ ist. Als Matrix sieht die Operation so aus: $CNOT = \begin{bmatrix}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0\end{bmatrix}$.
\end{itemize}
Diese Gatter sind die wichtigsten Gatter im Bereich des Quantum Computing. Wir werden auf unserem Weg jedoch weitere Gatter antreffen. Eines davon, von dem wir noch mehr Gebrauch machen werden, möchte ich hier kurz definieren. Ich nenne es $Rot(k)$ und in Matrix-Form sieht es so aus: $Rot(k) = \begin{bmatrix}1 & 0 \\ 0 & e^{\frac{2i\pi}{2^k}}\end{bmatrix}$. Dieses Gatter multipliziert den Koeffiztienten von $\ket{1}$ mit $e^{\frac{2i\pi}{2^k}}$ und wir werden es bei der Quanten-Fouriertransformation und dessen Anwendungen antreffen.

Abschliessend möchte ich noch ein Gatter auf zwei Qubits erwähnen, bekannt als das SWAP-Gate. Dieses Gate wechselt die Zustände der beiden Qubits. Dieses Gatter implementiert die Matrix: $$ SWAP = \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} = \begin{bmatrix}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0\end{bmatrix} \begin{bmatrix}0 & 1 & 0 & 0 \\ 1 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0\end{bmatrix}$$
Die rechte Seite zeigt uns, dass wir $SWAP(A, B)$ als $CNOT(A, B)$, $CNOT(B, A)$ und $CNOT(A, B)$ implementieren können.