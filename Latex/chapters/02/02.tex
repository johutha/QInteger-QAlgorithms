\chapter{Grundlagen}
\section{Lineare Algebra}

\section{Quantensysteme}
\subsection{Qubits}
Die Quantensysteme, die wir im Bereich des Quantum Coputing anschauen, sind rein mathemathematische Systeme, die auf keiner fixen physikalische Realisierung basieren. Dies bedeutet, dass es verschiedene Implementierungen gibt, die sich je nach Situation besser oder weniger gut eignen.

\textbf{Definition 2.2.1:} Ein \textbf{Qubit} ist das kleinste Quantensystem und damit die kleinste Informationseinheit in einem Quantencomputer. Das System hat die beiden Basiszustände $\ket{0}$ und $\ket{1}$ und kann somit alle Zustande $\alpha\ket{0} + \beta\ket{1}$ mit $\abs*{\alpha}^2 + \abs*{\beta}^2 = 1$ annehmen.

Falls $\alpha$ und $\beta$ beide nicht 0 sind, dann ist das Qubit gleichzeitig $\ket{0}$ und $\ket{1}$. Dies nennt man eine Superposition. 

Den Zustand $\alpha\ket{0} + \beta\ket{1}$ kann man auch mit einem Vektor $\begin{bmatrix}\alpha \\ \beta\end{bmatrix}$ darstellen. Die Bedingung, dass $\abs*{\alpha}^2 + \abs*{\beta}^2 = 1$ gelten muss, bedeutet, dass der Vektor normiert sein muss. Die Chance, den Zustand $\ket{0}$ zu messen, $\abs*{\alpha}^2$, und für den Zustand $\ket{1}$ gleich $\abs*{\beta}^2$ ist. Hier sehen wir wieder, dass der Vektor normiert sein muss, denn sonst würden sich die Wahrscheinlichkeiten nicht auf 1 summieren.
Genereller lassen sich Zustände, die $n$ Qubits involvieren, als Vektoren von Grösse $2^n$ darstellen. Sei $a_j$ der $j$-te Eintrag in jenem Vektor. Die Chance, den Zustand $j$ zu messen, wobei das $k$-te Qubit dann im Zustand $\lfloor \frac{j}{2^k} \rfloor \pmod{2}$ ist (was einfach dem $k$-ten Bit in der Binärdarstellung von $j$ entspricht), ist dann $\abs*{\alpha_j}^2$. Auch hier summieren sich die Wahrscheinlichkeiten auf 1, da der Vektor normiert ist. Man kann diese Zustände aber auch in Form eines mathematischen Ausdrucks $\alpha_0\ket{0} + ... + \alpha_j\ket{j} + ... + \alpha_{2^n - 1}\ket{2^n - 1}$ oder $\alpha_{00\dots}\ket{00\dots} + ... + \alpha_{j}\ket{j} + ... + \alpha_{11\dots}\ket{11\dots}$ darstellen, wobei in der zweiten Schreibweise $j$ ein Bitstring von Länge $n$ ist.

Gehen wir zurück zum einzelnen Qubit im Zustand $\alpha\ket{0} + \beta\ket{1}$. Wir wissen schon, dass wir bei einer Messung mit einer Wahrscheinlichkeiten von $\abs*{\alpha}^2$ den Zustand $\ket{0}$ messen. Nach dieser Messung kollabiert das Quantensystem in den gemessenen Zustand. Das heisst, messen wir den Zustand $\ket{0}$, befindet sich das Quantensystem nachher im Zustand $\ket{0}$, egal, wie $\alpha$ und $\beta$ vorher waren. Dies gilt auch für Multi-Qubit Systeme. Diese kollabieren dann in die noch möglichen Quantenpositionen. Nehmen wir als Beispiel ein 2-Qubit-System im Zustand $\frac{1}{\sqrt{6}}\ket{00} + \frac{1}{\sqrt{2}}\ket{01} + \frac{1}{\sqrt{3}}\ket{11}$ und messen das erste Qubit. Die Chance, dass wir dieses Qubit im Zustand $\ket{1}$ messen, liegt bei $\abs*{\alpha_{10}}^2 + \abs*{\alpha_{11}}^2 = \frac{1}{3}$. Falls wir diesen Zustand messen, kollabiert unser Quantensystem sofort in den Zustand $\frac{\alpha_{10}\ket{10} + \alpha_{11}\ket{11}}{\sqrt{\abs*{\alpha_{10}}^2 + \abs*{\alpha_{11}}^2}} = \ket{11}$, wobei die Summe im Nenner dafür sorgt, dass der neue Quantenzustand wieder normalisiert ist. Die Chance eines $\ket{0}$ in der Messung des ersten Qubit hingegen liegt bei $\abs*{\alpha_{00}}^2 + \abs*{\alpha_{01}}^2 = \frac{2}{3}$. Der Zustand des Systems nach der Messung ist dann $\frac{\alpha_{00}\ket{00} + \alpha_{01}\ket{01}}{\sqrt{\abs*{\alpha_{00}}^2 + \abs*{\alpha_{01}}^2}} = \sqrt{\frac{1}{4}}\ket{00} + \sqrt{\frac{3}{4}}\ket{01}$.
Dass diese Zustände rein mathematisch durch Vektoren darstellen lassen, hat zur Folge, dass man Quanten verschränken kann. Dafür schauen wir uns den einfach realisierbaren Zustand $\frac{1}{\sqrt{2}}(\ket{00} + \ket{11})$. Nun platzieren wir das eine Qubit auf die eine Seite des Universums, und das andere Qubit auf die andere Seite. Dann messen wir das erste Qubit. Die beiden Zustände $\ket{0}$ und $\ket{1}$ haben dabei die gleiche Wahrscheinlichkeit. Das andere Qubit auf der anderen Seite des Universums, kollabiert darauf sofort in den gleichen Zustand wie das erste. Ich habe dabei die beiden Seiten des Universums gewählt, um darauf aufmerksam zu machen, dass diese Qubits miteinander verknüpft sind, und dabei physikalische Distanz keine Rolle spielt.

\subsection{Die Blochkugel}
Die Blochkugel ist ein Instrument, um den Zustand eines einzelnen Qubits graphisch darzustellen. Dazu nehmen wir nochmals ein einzelnes Qubit $\alpha\ket{0} + \beta\ket{1}$ mit $\abs*{\alpha}^2 + \abs*{\beta}^2 = 1$. Diese Bedingung führt dazu, dass wir den Zustand als $e^{i\gamma}\left(cos\frac{\theta}{2}\ket{0} + e^{i\varphi}sin\frac{\theta}{2}\ket{1}\right)$. Der Faktor $e^{i\gamma}$ können wir nicht beobachten, da er auf alle Koeffizienten wirkt. Deshalb ist der Zustand durch die beiden Winkel $\theta$ und $\varphi$ definiert. Diese beiden Winkel kann man graphish als einen Punkt auf der Einheitskugel darstellen.

\begin{tikzpicture}
    \def\radius{3}
    \draw (0,0) node[circle,fill,inner sep=1] (center) {} -- (\radius/3,\radius/2) node[circle,fill,inner sep=0.7,label=above:$\alpha\ket{0} + \beta\ket{1}$] (pnt) {};
    \draw[dashed] (center) -- (\radius/3,-\radius/5) node (phi) {} -- (pnt);
    \draw (center) circle (\radius);
    \draw[dashed] (center) ellipse (\radius{} and \radius/3);
    \draw[->] (center) -- ++(-\radius/5,-\radius/3) node[below] (xaxis) {$x$};
    \draw[->] (center) -- ++(\radius,0) node[right] (yaxis) {$y$};
    \draw[->] (center) -- ++(0,\radius) node[above] (zaxis) {$z$};
    \pic [draw=black,text=black,->,"$\phi$"] {angle = xaxis--center--phi};
    \pic [draw=black,text=black,<-,"$\theta$"] {angle = pnt--center--zaxis};
\end{tikzpicture}

\subsection{Operationen auf Qubits}
Die Operationen, die man auf Qubits implementiert, sind lineare Operationen und lassen sich deshalb als Matrizen darstellen. Dann kann man den Zustandsvektor mit der Matrix des Operators multiplizieren, um den Zustand nach der Operation zu bekommen. Weiterhin entwickeln sich Quantensysteme nach einem Postulat der Quantenmechanik die Schrödinger-Gleichung erfüllend, was dazu führt, dass die implementierten Operatoren unitär sein müssen. Dies hat die direkte Konsequenz (für eine unitäre Matrix $U$ gilt $UU^{\dagger} = I$), dass ein inverser Operator existieren muss, und deshalb alle Berechnungen reversibel sein müssen. Dies führt dazu, dass der Modulo Operator nicht auf Quanten implementiert werden kann, da man aus dem Ergebnis $x \equiv 2 \pmod{3}$ die Eingabe $x \in \{2, 5, 8\cdots\}$ nicht eindeutig wiederherstellen kann. Dies hat grosse Konsequenzen für die Berechnungen auf Quantencomputer. Gleichzeitig stellt sich heraus, dass sich alle unitäre Matrizen sich beliebig annähern lassen. Die Konstruktion dazu kann man in [QC], Seiten 188ff., nachlesen.

\subsection{Wichtige Quantengatter}
Hier sollen kurz die wichtigsten Quantengatter eingeführt werden, die wir benötigen werden. Zuerst schauen wir uns 5 grundlegende Gatter auf Qubits an, die 3 Pauli-Matrizen, das $H$-Gatter und das $CNOT$-Gatter.
\begin{itemize}
    \item Das $X$-Gatter ist das Qubit-Equivalent zum $NOT$-Gatter. In Matrixform sieht der Operator so aus: $ X = \begin{bmatrix}0 & 1 \\ 1 & 0\end{bmatrix}$. Dieses Gatter dreht den Zustand des Qubits um $\pi$ um die $x$-Achse in der Blochkugel.
    \item Das $Y$-Gatter implementiert die Operation der Matrix $Y = \begin{bmatrix}0 & -i \\ i & 0\end{bmatrix}$. Dieses Gatter entspricht einer Rotation von $\pi$ um die $y$-Achse in der Blochkugel.
    \item Das $Z$-Gatter, als Matrix $Z = \begin{bmatrix}1 & 0 \\ 0 & -1\end{bmatrix}$, dreht den Zustand um $\pi$ um die $z$-Achse.
    \item Das $H$-Gatter ist der einfachste Weg, eine Superposition zu erzeugen. Mit der Matrix $H = \frac{1}{\sqrt{2}}\begin{bmatrix}1 & 1 \\ 1 & -1\end{bmatrix}$ kann man ganz die beiden Zustände $H\ket{0} = \frac{1}{\sqrt{2}}(\ket{0} + \ket{1})$ und $H\ket{1} = \frac{1}{\sqrt{2}}(\ket{0} - \ket{1})$ erzeugen. Diese beiden Zustände kommen so oft vor, dass man ihnen die Namen $\ket{+} = \frac{1}{\sqrt{2}}(\ket{0} + \ket{1})$ und $\ket{-} = \frac{1}{\sqrt{2}}(\ket{0} - \ket{1})$ gegeben hat.
    \item $CNOT$ steht als Abkürzung für "Controlled NOT". Dieses Gatter wirkt auf zwei Qubits und wendet ein $NOT$ auf das zweite Qubit an, wenn das erste Qubit auf $1$ ist. Als Matrix sieht die Operation so aus: $CNOT = \begin{bmatrix}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0\end{bmatrix}$.
\end{itemize}
Diese Gatter sind die wichtigsten Gatter im Bereich des Quantum Computing. Wir werden jedoch auf unserem Weg noch weitere Gatter antreffen. Eines davon, von dem wir noch mehr Gebrauch machen werden, möchte ich hier noch kurz definieren. Dieses Gatter nenne ich $Rot(k)$ und in Matrix-Form sieht es so aus: $Rot(k) = \begin{bmatrix}1 & 0 \\ 0 & e^{\frac{2i\pi}{2^k}}\end{bmatrix}$. Dieses Gatter multipliziert den Koeffiztienten von $\ket{1}$ mit $e^{\frac{2i\pi}{2^k}}$ und wir werden es bei der Quanten-Fouriertransformation und dessen Anwendungen antreffen.

Zuletzt möchte ich noch ein Gatter auf zwei Qubits erwähnen, bekannt als das SWAP-Gate. Dieses Gate wechselt die Zustände der beiden Qubits. Dieses Gatter implementiert die Matrix: $$ SWAP = \begin{bmatrix} 1 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} = \begin{bmatrix}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0\end{bmatrix} \begin{bmatrix}0 & 1 & 0 & 0 \\ 1 & 0 & 0 & 0 \\ 0 & 0 & 1 & 0 \\ 0 & 0 & 0 & 1 \end{bmatrix} \begin{bmatrix}1 & 0 & 0 & 0 \\ 0 & 1 & 0 & 0 \\ 0 & 0 & 0 & 1 \\ 0 & 0 & 1 & 0\end{bmatrix}$$
Die rechte Seite zeigt uns, dass wir $SWAP(A, B)$ als $CNOT(A, B)$, $CNOT(B, A)$, und $CNOT(A, B)$ implementieren können.