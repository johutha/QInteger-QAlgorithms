\chapter{Arithmetische Operation auf Qubits ausführen - Die QInteger Library}
\section{Überblick}

\section{Zahlen in Qubits speichern - Der QInt-Typ}
Da ich davon ausgehe, dass in nächster Zeit die Anzahl Qubits zwar wachsen wird, aber nicht so schnell ansteigen, dass man schon bald mehrere grössere Qubit-Einheiten speichern kann, habe ich mich entschieden, in meiner Implementation auf eine einheiltiche Grösse zu verzichten. Deshalb der QInt-Typ aus einer klassischen Zahl, die Anzahl Qubits, und einem Array von Qubits, welcher die eigentliche Zahl speichert. Ich habe mich auch dazu entschieden, die Quantenzahl im Little-Endian Format zu speichern, da so neue Qubits einfach angehängt werden können ohne den Wert der Zahl zu verändern. 

\lstinputlisting[language=C++]{assets/code/3/3.2.1}

\section{Die Quanten-Fouriertransformation und die Fourier-Basis}
Die Quanten-Fouriertransformation ist eine Transformation, die eine Quantenzahl von der uns bekannten binären Basis in die Fourierbasis transformiert. Die Fouriertransformation, die dabei auf den Qubits implementiert ist, ist mathematisch definiert als eine Transformation, die zu einem Vektor $(x_0, x_1, ..., x_{n - 1})$ zum Vektor $(y_0, y_1, ..., y_{n - 1})$ transformiert, mit $y_k = \frac{1}{\sqrt{n}}\sum_{j = 0}^{n - 1}x_je^{2i\pi\frac{kj}{n}}$. Da dies ein linearer Operator ist, genügt es, wenn wir uns die Wirkung des Operators auf den Basiszuständen anschauen. Schauen wir also die Wirkung des Operators auf den Basiszustand $\ket{x}$ an. Wir erhalten:
$$QFT\ket{x} = \frac{1}{\sqrt{2^n}}\sum^{2^n - 1}_{j = 0}e^{2i\pi\frac{xj}{2^n}}\ket{j}$$
Gleichzeitig lässt dieser Zustand sich faktorisieren, nämlich zu:
\begin{align*}
(\ket{0} + e^{2i\pi\frac{x}{2^{n}}}\ket{1})\otimes(\ket{0} + e^{2i\pi\frac{x}{2^{n - 1}}}\ket{1})\otimes\cdots\otimes(\ket{0} + e^{2i\pi\frac{x}{2^{1}}}\ket{1}) = \\ \bigotimes_{j = 0}^{n - 1}(\ket{0} + e^{2i\pi\frac{x}{2^{n - j}}}\ket{1})
\end{align*}
Dies kann man durch ausmultiplizieren beweisen. Um die folgende Gleichung zu vereinfachen, sei hier $b_k(j) = 1$ falls das $k$-te Bit von $j$ gesetzt ist, und $b_k(j) = 0$ falls nicht. Dazu sie $B_j$ als das Set aller $k \in \mathbb{N}_0$ mit $b_k(j) = 1$. Dann bekommen wir:
\begin{align*}
\frac{1}{\sqrt{2^n}}\bigotimes_{j = 0}^{n - 1}\left(\ket{0} + e^{2i\pi\frac{x}{2^{n - j}}}\right) = \frac{1}{\sqrt{2^n}}\sum_{j = 0}^{2^n - 1}\left(\prod_{k \in B_j}e^{2i\pi\frac{x}{2^{n - k}}}\right)\ket{j} \\ \\
= \frac{1}{\sqrt{2^n}}\sum_{j = 0}^{2^n - 1}e^{2i\pi\sum_{k = 0}^{n - 1}\left(\frac{x \cdot b_k(j)}{2^{n - k}}\right)}\ket{j} = \frac{1}{\sqrt{2^n}}\sum_{j = 0}^{2^n - 1}e^{2i\pi\frac{x\sum_{k = 0}^{n - 1}\left(2^k\cdot b_k(j)\right)}{2^n}}\ket{j} \\ \\
= \frac{1}{\sqrt{2^n}}\sum_{j = 0}^{2^n - 1}e^{2i\pi\frac{xj}{2^n}}\ket{j}
\end{align*}
Was bringt uns diese Faktorisierung? Zuerst stellen wir fest, dass die Bits unabhängig und nicht verschränkt sind. Gleichzeitig schauen wir uns die einzelnen Qubits mit Hilfe der Blochkugel an. Wir stellen fest, der Zustand $\frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi\theta}\ket{1})$ in der Blochkugel einer Rotation von $\theta$ Grad um die $Z$-Achse in der $XY$-Ebene entspricht. Schauen wir uns die einzelnen Bits an, entspricht das $j$-te Bit einer Rotation von $\frac{x}{2^{n - j}}$ um die $Z$-Achse. Dies ist die sogenannte Fourier-Basis.

Nun kann man sich überlegen, was denn der Grosse Vorteil der Fourier-Basis ist. Die Fourierbasis hat verschiedene Vorteile. Zum Beispiel werden wir im Kapitel 4.3 sehen, dass wenn wir in einer Operation ein Qubit um $\theta$ um die Z-Achse drehen, was der Multiplikation des Koeffizienten von $\ket{1}$ mit dem Wert $e^{2i\pi\theta}$ entpricht, machen wir nichts anderes, als den Wert der Qubits in der Fourierbasis zu verändern. Später können wir dann die inverse $QFT$ anwenden, um den Wert $\theta$ als Binärzahl auslesen zu können. Ein anderer grosser Vorteil der Fourierbasis ist, dass die einzelnen Qubits voneinander unabhängig sind. Dass dies ein grosser Vorteil ist, werden wir feststellen, wenn wir die Addition auf Qubits implementieren.

Die letzte Frage, die es nun noch zu klären gilt, ist, wie man diese Transformation nun implementiert. Wir werden sehen, wie man die Transformation mit $\mathcal O(n^2)$ Gatteroperationen implementieren kann, ohne zusätzliche Qubits. Schauen wir uns nochmals die Faktorisierung an.

TODO - Factorization, each Bit in Computational Basis only affects Bits to the left in Fourier Basis.

\section{Addition}
Die wohl grundlegendste arithmetische Operation ist die Addition. Die Subtraktion kann als Addition ausgedrückt werden, und auch die Multiplikation (somit auch die Division) sind abhängig von der Addition. Deshalb ist es die erste arithmetische Operation, die wir uns hier anschauen. Wir wollen dabei die Operation auf zwei Qints implementieren, welche zwei QInts im Zustand $(\ket{x}, \ket{y})$ in den Zustand $(\ket{x}, \ket{x + y})$ transformiert. Die Implementation anderer Additionsmethoden (Addition einer klassischen Zahl zu einem QInt, Addition zweier QInts in ein drittes QInt) funktionieren Analog. Zusätzlich kann man auch sehen, dass die Subtraktion nichts anderes als die inverse Operation zur Addition ist, somit hat man zur Addition gleich noch die Subtraktion mit-implementiert.

Heutzutage sind zwei verschiedene Additions-Techniken bekannt. Die eine benutzt zusätzliche Carry-Bits, und erreicht so eine Gatterzahl in $\mathcal O(n)$, braucht dafür aber $\mathcal O(n)$ zusätzliche Qubits, während die andere ohne zusätzliche Qubits auskommt, dafür aber $\mathcal O(n^2)$ zusätzliche Gatteroperationen benötigt. Ich habe mich entschieden, für den Moment die zweite Version in meiner QInteger-Library zu implementieren. Gründe dazu sind, dass in heutigen Systemen die Anzahl verfügbarer Qubits stark begrenzt sind und in Simulationen einzelne Qubits sehr viel Leistung kosten, während eine Laufzeit von $\mathcal O(n^2)$ in diesem Fall weniger ausmacht. Wenn dann aber mehr Qubits zur Verfügung stehen, wird es wahrscheinlich lohnenswerter, auf die andere Version zu wechseln, denn da Addition eine sehr "low-level" (TODO besseres Wort?) Operation ist, kann die Zeit, welche die Addition benötigt, sehr grosse Auswirkungen auf die gesamte Laufzeit haben.

Schauen wir uns nun den in der QInteger-Library verwendete Additionsalgorithmus an. Der Algorithmus basiert auf der Fourierbasis (und damit auf der Faktorisierung der Fouriertransformation). Bei der Addition in der binären sind die einzelnen Bits voneinander abhängig. Deshalb werden sogenannte Carry-Bits verwendet, welche für jedes Bit abspeichern, ob wir beim nächsten Bit noch ein zusätzliches $1$ addieren müssen. Dies ist bei der Fourierbasis nicht so: Die Bits sind voneinander unabhängig. Das heisst, wir können die einzelnen Bits voneinander unabhängig modifizieren, ohne dabei auf die anderen Bits achten zu müssen. Dies ist der grosse Vorteil der Fourier-Basis, welcher uns erlaubt, auf zusätzliche Qubits zu verzichten. Schauen wir uns nochmals die Faktorisierung an: Das $j$-te Qubit der Zahl $y$ in der Fourierbasis ist im Zustand $\frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi\frac{y}{2^{n - j}}}\ket{1})$. Wir wollen es aber in den Zustand $\frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi\frac{x + y}{2^{n - j}}}\ket{1})$ bringen, denn wenn wir alle Qubits in den entsprechenden Zustand bringen könnten, könnten wir mit der inversen $QFT$ den Zustand $\ket{x + y}$ wiederherstellen. Dies ist aber nicht zu schwierig. Nehmen wir wieder das aus der Fouriertransformation bereits bekannte Gatter $Rot(k) = \frac{1}{\sqrt{2}}\begin{bmatrix}
    1 & 0 \\
    0 & e^{\frac{2i\pi}{2^k}} \\
\end{bmatrix}$. Mit dem Gatter können wir den Wert $2i\pi\frac{1}{2^k}$ dem Exponenten von $\ket{1}$ hinzufügen. Das heisst, wenn wir das Gatter auf ein Qubit im Zustand $\frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi\frac{y}{2^{n - j}}}\ket{1})$ anwenden, wird es in den Zustand $\frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi\frac{y + 2^{n - j - k}}{2^{n - j}}}\ket{1})$ versetzt. Wir können also mit Hilfe dieses Gatters Zweierpotenzen dem Qubit in der Fouriertransformation addieren. Wenn wir also das Qubit im Zustand $\ket{x}$ in der binären Basis lassen, können wir die Addition wie folgt mit $\mathcal O(n^2)$ Gatteroperationen implementieren:
\begin{enumerate}
    \item Wende $QFT$ auf den zweiten Summanden im Zustand $\ket{y}$ an. Das Register is nun im Zustand $\frac{1}{\sqrt{2^n}}\bigotimes_{j = 0}^{n - 1}\left(\ket{0} + e^{2i\pi\frac{y}{2^{n - j}}}\right)$.
    \item Für das jedes $j$-te Bit im zweiten Register, wende für jedes $k$-te Bit im ersten (binären) Register mit $k < n - j$ ein kontrolliertes $Rot(n - i - j)$ an. Das $j$-te Bit befindet sich nachher im Zustand 
    \begin{align*}
        \frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi\frac{y + \sum_{k = 0}^{n - j - 1}{b_k(x)\cdot 2^{n - j - (n - j - k)}}}{2^{n - j}}}\ket{1})
        = \frac{1}{\sqrt{2}}(\ket{0} + e^{2i\pi\frac{y + x}{2^{n - j}}}\ket{1})
    \end{align*}
    Wobei alle Bits höher als $2^{n - j - 1}$ uns nicht interessieren, da sie alle Vielfaches von $2^{n - j}$ sind, und somit nur gane Umrundungen zur Rotation hinzufügen.
    \item Die Qubits im zweiten Register befinden sich nun in folgendem Zustand: $\frac{1}{\sqrt{2^n}}\bigotimes_{j = 0}^{n - 1}\left(\ket{0} + e^{2i\pi\frac{x + y}{2^{n - j}}}\right)$. Mit der inversen $QFT$ kann man nun aus diesem Zustand den Zustand $\ket{x + y}$ wiederherstellen.
\end{enumerate}
\section{Modulare Addition}
Bei Shor braucht man aber nicht nur Addition, sondern modulare Addition. Den uns bekannten Modulo-Operator kann man auf Qubits nicht implementieren, da er nicht reversibel ist ($a$ und $a + m$ haben das selbe Resultat Modulo $m$). Die modulare Addition ist jedoch reversibel, wenn die Summanden kleiner als das Modulo sind. Dafür benutzen wir Information über die beiden Summanden. Dafür haben wir wieder drei Register in den Zuständen $\ket{x}, \ket{y}$ und $\ket{m}$, und möchten sie in den Zustand $\ket{x}, \ket{(x + y) \% m}$ und $\ket{m}$. Theoretisch kann man das dritte Register durch ein klassisches Register ersetzten, wenn das $m$ eine klassische Zahl ist. Für den Algorithmus von Shor werden wir auch nur die modulare Addition modulo eine klassische Zahl brauchen, aber um aufzuzeigen, dass man es auch mit QInt-Modulos implementieren kann, präsentiere ich hier diese Version. Die andere Implementation folgt analog. 

Zuerst addieren wir $x$ zum Register $\ket{y}$, um das Register in den Zustand $\ket{x + y}$ zu versetzen. Nun überprüfen wir, ob diese Summe grössergleich dem Modulo $m$ ist. 

Wie überprüfen wir ob eine Zahl grössergleich einer anderen Zahl ist? Sagen wir, ob $\ket{A}$ grössergleich $\ket{B}$ ist, wobei $B$ auch eine normale Zahl sein könnte? In der QInteger-Library ist die Funktion $GreaterOrEqual$ für $A >= B$ als ¬$LessThan$ implementiert. Hier unterscheiden sich die Implementationen für de Fälle wenn $B$ ein QInt oder eine klassische Zahl ist, sie machen jedoch ungefähr das Gleiche. Wir schauen uns die Implementation für den Fall an, wenn $B$ eine klassische Zahl ist. Wir wissen, dass $A >= B$ gilt (für $A$ und $B$ ganze Zahlen), falls $A - B < 0$ oder $A - B == 0$ gilt. Da nicht beide Bedingungen gleichzeitig erfüllt sein können, können wir die Resultate der beiden Checks einfach "addieren" (TODO besseres Wort oder Beschreibung). Ein QInt ist genau dann gleich 0, wenn alle seine Qubits auf 0 sind. Gleichzeitig, falls das Resultat der Subtraktion kleiner als $0$ sein soll, gibt es einen Underflow, was so viel bedeuted, dass die Zahl $A - B$ zu $2^n - (B - A)$ wird, und somit das erste Qubit auf 1 gesetzt wird. Das heisst, wir können einfach das erste Qubit überprüfen, ob es auf eins gesetzt ist. Es kann aber passieren, dass $A - B >= 2^{n - 1}$ gelten kann, deshalb verlängere ich in meiner Implementation das Register, welches $A$ enthält, um 1.

TODO Insert code

Nun können wir messen, ob $x + y >= m$ gilt, und diese Information in einem zusätzlichen Qubit speichern. Falls $x + y >= m$ gilt, subtrahieren wir $m$ von der Zahl und bekommen den Zustand $\ket{x + y - m}$ im zweiten Register. Nun haben wir aber noch Problem, dass die Information, ob $x + y >= m$ gilt, noch in einem Qubit gespeichert wird, welches wir noch zurücksetzen müssen. Hier machen wir die Beobachtungen, dass $x + y >= m$ genau dann gilt, wenn das Resultat grössergleich dem Summanden $x$ ist. Die Richtung $res < x \rightarrow x + y >= m$ ist nicht schwierig. Für die andere Richtung sehen wir, dass $x + y - m >= x$ Nur dann gelten kann, falls $y >= m$ gilt, was aber nach der Annahme $x, y < m$ nicht gelten kann. Somit können wir mit diesem Vergleich die Information in unserem Aushilfsqubit wieder löschen.

\section{Modulare Multiplikation}
Mit Hilfe der Modularen Addition können wir nun die modulare Multiplikation implementieren. Zuerst stellen wir fest, dass wir die Moudulare Multiplikation $\ket{x} \rightarrow \ket{(ax) \pmod{m}}$ nur dann implementieren können, wenn $ggT(a, m) = 1$ gilt, denn sonst wäre sie nicht reversiel. \newline
Wir schauen uns die modulare Multiplikation auf QInts in zwei Schritten an.

Zuerst implementieren die Quantenoperation auf zwei Register, welche für gegebenes $a$ und $m$ folgende Operation implementiert: $$U'_{a, m}\ket{x}\ket{y} = \ket{x}\ket{(y + ax) \pmod{m}}$$.
Dafür sehen wir, dass wenn wir $x = 2^0 x_0 + 2^1 x_1 ...$ in seine Zweierpotenzen aufteilen, dann können wir $ax = x_0(2^0 a \pmod{m}) + x_1(2^1 a \pmod{m}) + ...$ schreiben. Dieses $+ \;x_0(...)$ ist nichts anders als Addition, kontrolliert durch das $x_0$ Qubit. Dies heisst, wir können diese Operation relativ einfach durchführen: \newline
Für jedes $j$, führe eine modulare Addition, kontrolliert durch das Qubit $x_j$, auf das Ausgaberegister mit dem Summanden $2^ja \pmod{m}$ durch, den wir klassisch berechnen können. \newline
Diese Unteroperation ruft den modularen Addierer $\mathcal O(n)$ mal auf und jede dieser Additionen braucht $\mathcal O(n^2)$ Gatteroperationen. Damit kommen wir auf $\mathcal O(n^3)$ Gatteroperationen.

Mit Hilfe dieser Unteroperation können wir nun die Operation, welche $$U_{a, m}\ket{x} = \ket{(ax) \pmod{m}}$$ bewirkt, implementieren:
\begin{enumerate}
    \item Führe ein temporäres Register im Zustand $\ket{0}$ ein, und bringe es mit Hilfe der oberen Unteroperation den Zustand $\ket{ax \pmod{m}}$.
    \item Berechne klassisch das Inverse von $a$ Modulo $m$. Dieses Inverse existiert, da $a$ und $m$ teilerfremd sind.
    \item Wende die inverse Operation der oben definierten Unteroperation mit $a^{-1}$ mit dem temporären Register als Eingaberegister und dem ersten Register als Ausgaberegister an. Dies ergibt dann den Zustand $$\ket{x - a^{-1}(ax) \pmod{m}}\ket{ax \pmod{m}} = \ket{0}\ket{ax \pmod{m}}$$.
    \item Wechsle den Wert der beiden Register mit Hilfe der Swap-Oeration, wir bekommen den Zustand $\ket{ax \pmod{m}}\ket{0}$. Das temporöre Register im Zustand $\ket{0}$ können wir wieder freigeben und das erste Register ist nun im Zustand $\ket{ax \pmod{m}}$.
\end{enumerate}
Diese Multiplikation benötigt $n$ extra Qubits für das temporäre Register. Sie ruft die Unteroperation $2 \in \mathcal O(1)$ mal auf, und benötigt somit $\mathcal O(n^3)$ Gatteroperationen. Wir erinnern uns daran, dass man die Addition mit $O(n)$ Gatteroperationen und dafür $n$ zusätzlichen Qubits implementieren kann, was dazu führt, dass wir nur noch $O(n^2)$ Gatteroperationen benötigen, dafür aber $2n$ extra Qubits benötigen.